/**
 * @file tkl_gpio.c
 * @brief this file was auto-generated by tuyaos v&v tools, developer can add implements between BEGIN and END
 * 
 * @warning: changes between user 'BEGIN' and 'END' will be keeped when run tuyaos v&v tools
 *           changes in other place will be overwrited and lost
 *
 * @copyright Copyright 2020-2021 Tuya Inc. All Rights Reserved.
 * 
 */

// --- BEGIN: user defines and implements ---
#include "tkl_gpio.h"
#include "tuya_error_code.h"
#include "osal/osal.h"
#include "hal/hal_gpio.h"
// --- END: user defines and implements ---

static uint32_t __pin_get_base(TUYA_GPIO_NUM_E pin);
static gpio_pin_t __pin_get_num(TUYA_GPIO_NUM_E pin);

#define GPIO_NUM_MAX    19

// true -> in range; false -> not in range
#define LN_PIN_IS_IN_RANGE(port, pin)   (((port == GPIOA_BASE) || (port == GPIOB_BASE)) && \
                                        ((pin <= GPIO_PIN_15) && (pin != 0)))

#define LN_PIN_PARAM_CHECK(port, pin, error_no)      \
    do {                                             \
        if (!LN_PIN_IS_IN_RANGE(port, pin)) {        \
            return error_no;                         \
        }                                            \
    } while(0)


struct tuya_ln_gpio_conv {
    TUYA_GPIO_NUM_E tuya_pin;
    uint32_t        base;
    gpio_pin_t      ln_pin;
};

/* gpio irq */
typedef struct {
    TUYA_GPIO_NUM_E  tuya_pin;
    TUYA_GPIO_IRQ_CB cb;
    uint8_t          used_flag;
    void            *arg;
}GPIO_IRQ_CB_S;

static const struct tuya_ln_gpio_conv io_map[GPIO_NUM_MAX] = {
    {0,     GPIOB_BASE,     GPIO_PIN_9},    // PB9
    {1,     GPIOB_BASE,     GPIO_PIN_8},    // PB8
    {6,     GPIOA_BASE,     GPIO_PIN_11},   // PA11
    {7,     GPIOA_BASE,     GPIO_PIN_10},   // PA10
    {8,     GPIOA_BASE,     GPIO_PIN_7},    // PA7
    {9,     GPIOB_BASE,     GPIO_PIN_5},    // PB5
    {10,    GPIOA_BASE,     GPIO_PIN_3},    // PA3
    {11,    GPIOA_BASE,     GPIO_PIN_2},    // PA2
    {14,    GPIOA_BASE,     GPIO_PIN_5},    // PA5
    {15,    GPIOB_BASE,     GPIO_PIN_7},    // PB7
    {16,    GPIOA_BASE,     GPIO_PIN_6},    // PA6
    {17,    GPIOB_BASE,     GPIO_PIN_6},    // PB6
    {20,    GPIOA_BASE,     GPIO_PIN_4},    // PA4
    {21,    GPIOA_BASE,     GPIO_PIN_9},    // PA9
    {22,    GPIOA_BASE,     GPIO_PIN_1},    // PA1
    {23,    GPIOA_BASE,     GPIO_PIN_0},    // PA0
    {24,    GPIOB_BASE,     GPIO_PIN_3},    // PB3
    {26,    GPIOA_BASE,     GPIO_PIN_12},   // PA12
    {28,    GPIOB_BASE,     GPIO_PIN_4},    // PB4
};

static GPIO_IRQ_CB_S __irq_cb_info[GPIO_NUM_MAX];
static uint8_t  gpio_init_num  = 0;

static uint32_t __pin_get_base(TUYA_GPIO_NUM_E pin)
{
    for (int i = 0; i < GPIO_NUM_MAX; i++) {
        if (pin == io_map[i].tuya_pin)
            return io_map[i].base;
    }
    return 0;
}

static gpio_pin_t __pin_get_num(TUYA_GPIO_NUM_E pin)
{
    for (int i = 0; i < GPIO_NUM_MAX; i++) {
        if (pin == io_map[i].tuya_pin)
            return io_map[i].ln_pin;
    }
    return 0;
}

/**
 * @brief gpio init
 *
 * @param[in] pin_id: gpio pin id, id index starts at 0
 * @param[in] cfg:  gpio config
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_gpio_init(TUYA_GPIO_NUM_E pin_id, const TUYA_GPIO_BASE_CFG_T *cfg)
{
    uint32_t    ln_base;
    gpio_pin_t  ln_pin;
    gpio_init_t_def ln_gpio_init;
    memset(&ln_gpio_init, 0, sizeof(ln_gpio_init));

    ln_base = __pin_get_base(pin_id);
    ln_pin =  __pin_get_num(pin_id);

    LN_PIN_PARAM_CHECK(ln_base, ln_pin, OPRT_INVALID_PARM);

    hal_gpio_pin_afio_en(ln_base, ln_pin, HAL_DISABLE);

    ln_gpio_init.pin   = ln_pin;
    ln_gpio_init.speed = GPIO_HIGH_SPEED;

    /* gpio direct config */
    switch (cfg->direct) {
        case TUYA_GPIO_INPUT:
            ln_gpio_init.dir = GPIO_INPUT;
            break;
        case TUYA_GPIO_OUTPUT:
            ln_gpio_init.dir = GPIO_OUTPUT;
            break;
        default:
            return OPRT_INVALID_PARM;
    }

    /* gpio pull config*/
    switch (cfg->mode) {
        case TUYA_GPIO_PULLUP:
            ln_gpio_init.pull = GPIO_PULL_UP;
            break;
        case TUYA_GPIO_PULLDOWN:
            ln_gpio_init.pull = GPIO_PULL_DOWN;
            break;
        case TUYA_GPIO_PUSH_PULL:
            ln_gpio_init.pull = GPIO_PULL_UP_AND_PULL_DOWN;
            break;
        default :
            ln_gpio_init.pull = GPIO_PULL_NONE;
            break;
    }

    /* gpio init */
    hal_gpio_init(ln_base, &ln_gpio_init);

    /* set pin level */
    if (TUYA_GPIO_LEVEL_LOW == cfg->level) {
        hal_gpio_pin_reset(ln_base, ln_pin);
    } else {
        hal_gpio_pin_set(ln_base, ln_pin);
    }

    return OPRT_OK;
}

/**
 * @brief gpio deinit
 *
 * @param[in] pin_id: gpio pin id, id index starts at 0
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_gpio_deinit(TUYA_GPIO_NUM_E pin_id)
{
    // --- BEGIN: user implements ---
    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

/**
 * @brief gpio write
 *
 * @param[in] pin_id: gpio pin id, id index starts at 0
 * @param[in] level: gpio output level value
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_gpio_write(TUYA_GPIO_NUM_E pin_id, TUYA_GPIO_LEVEL_E level)
{
    uint32_t    ln_base;
    gpio_pin_t  ln_pin;

    ln_base = __pin_get_base(pin_id);
    ln_pin =  __pin_get_num(pin_id);

    LN_PIN_PARAM_CHECK(ln_base, ln_pin, OPRT_INVALID_PARM);

    if (TUYA_GPIO_LEVEL_LOW == level)
        hal_gpio_pin_reset(ln_base, ln_pin);
    else
        hal_gpio_pin_set(ln_base, ln_pin);

    return OPRT_OK;
}

/**
 * @brief gpio read
 *
 * @param[in] pin_id: gpio pin id, id index starts at 0
 * @param[out] level: gpio output level
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_gpio_read(TUYA_GPIO_NUM_E pin_id, TUYA_GPIO_LEVEL_E *level)
{
    uint32_t    ln_base;
    gpio_pin_t  ln_pin;

    ln_base = __pin_get_base(pin_id);
    ln_pin =  __pin_get_num(pin_id);

    LN_PIN_PARAM_CHECK(ln_base, ln_pin, OPRT_INVALID_PARM);

    *level = (HAL_RESET == hal_gpio_pin_read(ln_base, ln_pin) ? 0 : 1);

    return OPRT_OK;
}

/**
 * @brief gpio irq init
 * NOTE: call this API will not enable interrupt
 *
 * @param[in] pin_id: gpio pin id, id index starts at 0
 * @param[in] cfg:  gpio irq config
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_gpio_irq_init(TUYA_GPIO_NUM_E pin_id, const TUYA_GPIO_IRQ_T *cfg)
{
    uint32_t    ln_base;
    gpio_pin_t  ln_pin;
    gpio_int_type_t  type;

    ln_base = __pin_get_base(pin_id);
    ln_pin =  __pin_get_num(pin_id);

    LN_PIN_PARAM_CHECK(ln_base, ln_pin, OPRT_INVALID_PARM);

    if (cfg == NULL)
        return OPRT_INVALID_PARM;

    switch (cfg->mode) {
        case TUYA_GPIO_IRQ_RISE:
            type = GPIO_INT_RISING;
            break;
        case TUYA_GPIO_IRQ_FALL:
            type = GPIO_INT_FALLING;
            break;
        case TUYA_GPIO_IRQ_RISE_FALL:
            type = GPIO_INT_RISING_FALLING;
            break;
        default:
            return OPRT_NOT_SUPPORTED;
    }

    for (int i = 0; i < gpio_init_num; i++)
    {
        //Because there is no deinit, the number of pins(gpio_init_num)
        //must be initialized
        if(__irq_cb_info[i].tuya_pin == pin_id
                /*&& __irq_cb_info[i].used_flag == 1*/) {
            __irq_cb_info[i].cb      = cfg->cb;
            __irq_cb_info[i].arg     = cfg->arg;
            hal_gpio_pin_it_cfg(ln_base, ln_pin, type);
            return OPRT_OK;
        }
    }

    for(int i = 0; i < GPIO_NUM_MAX; i++){
        if(__irq_cb_info[i].used_flag == 0){
            __irq_cb_info[i].used_flag = 1;
            gpio_init_num ++;

            __irq_cb_info[i].tuya_pin = pin_id;
            __irq_cb_info[i].cb       = cfg->cb;
            __irq_cb_info[i].arg      = cfg->arg;
            hal_gpio_pin_it_cfg(ln_base, ln_pin, type);
            return OPRT_OK;
        }
    }

    return OPRT_COM_ERROR;
}

/**
 * @brief gpio irq enable
 *
 * @param[in] pin_id: gpio pin id, id index starts at 0
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_gpio_irq_enable(TUYA_GPIO_NUM_E pin_id)
{
    uint32_t    ln_base;
    gpio_pin_t  ln_pin;
    gpio_int_type_t  type;

    ln_base = __pin_get_base(pin_id);
    ln_pin =  __pin_get_num(pin_id);

    LN_PIN_PARAM_CHECK(ln_base, ln_pin, OPRT_INVALID_PARM);

    for(int i = 0; i < GPIO_NUM_MAX; i++) {
        if(__irq_cb_info[i].tuya_pin == pin_id) {
            if(__irq_cb_info[i].used_flag != 0) {
                hal_gpio_pin_it_en(ln_base, ln_pin, HAL_ENABLE);
                if (ln_base == GPIOB_BASE)
                    NVIC_EnableIRQ(GPIOB_IRQn);
                else if (ln_base == GPIOA_BASE)
                    NVIC_EnableIRQ(GPIOA_IRQn);
                return OPRT_OK;
            }
        }
    }

    return OPRT_COM_ERROR;
}

/**
 * @brief gpio irq disable
 *
 * @param[in] pin_id: gpio pin id, id index starts at 0
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_gpio_irq_disable(TUYA_GPIO_NUM_E pin_id)
{
    uint32_t    ln_base;
    gpio_pin_t  ln_pin;
    gpio_int_type_t  type;

    ln_base = __pin_get_base(pin_id);
    ln_pin =  __pin_get_num(pin_id);

    LN_PIN_PARAM_CHECK(ln_base, ln_pin, OPRT_INVALID_PARM);

    for(int i = 0; i < GPIO_NUM_MAX; i++) {
        if(__irq_cb_info[i].tuya_pin == pin_id) {
            if(__irq_cb_info[i].used_flag != 0) {
                hal_gpio_pin_it_en(ln_base, ln_pin, HAL_DISABLE);
                return OPRT_OK;
            }
        }
    }

    return OPRT_COM_ERROR;
}

static void __GPIO_IRQHandler(void)
{
    uint32_t    ln_base;
    gpio_pin_t  ln_pin;

    for (int i = 0; i < gpio_init_num; i++)
    {
        ln_base = __pin_get_base(__irq_cb_info[i].tuya_pin);
        ln_pin =  __pin_get_num(__irq_cb_info[i].tuya_pin);
        LN_PIN_PARAM_CHECK(ln_base, ln_pin, OPRT_INVALID_PARM);

        if (HAL_SET == hal_gpio_pin_get_it_flag(ln_base, ln_pin))
        {
            hal_gpio_pin_clr_it_flag(ln_base, ln_pin);
            if(__irq_cb_info[i].cb){
                __irq_cb_info[i].cb(__irq_cb_info[i].arg);
            }
        }
    }
}

void GPIOA_IRQHandler(void)
{
    __GPIO_IRQHandler();
}

void GPIOB_IRQHandler(void)
{
    __GPIO_IRQHandler();
}

