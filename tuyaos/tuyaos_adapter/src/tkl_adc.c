/**
 * @file tkl_adc.c
 * @brief this file was auto-generated by tuyaos v&v tools, developer can add implements between BEGIN and END
 * 
 * @warning: changes between user 'BEGIN' and 'END' will be keeped when run tuyaos v&v tools
 *           changes in other place will be overwrited and lost
 *
 * @copyright Copyright 2020-2021 Tuya Inc. All Rights Reserved.
 * 
 */

// --- BEGIN: user defines and implements ---
#include "tkl_adc.h"
#include "tuya_error_code.h"
#include "osal/osal.h"
#include "hal/hal_adc.h"
#include "hal/hal_gpio.h"
// --- END: user defines and implements ---

#define TKL_ADC_CODE_EN  1

#define ADC_NUM_MAX     2
#define ADC_READ_TIMEOUT    100 // unit: ms

typedef struct {
    TUYA_ADC_NUM_E  tuya_adc_num;
    uint32_t        gpio_base;
    gpio_pin_t      ln_pin;
    adc_ch_t        ln_adc_chan;
}TUYA_LN_ADC_CNV;

static unsigned char __temperature_ready = 0;
static adc_init_t_def __adc_cfg[ADC_NUM_MAX] = {0};

static TUYA_LN_ADC_CNV adc_io_map[ADC_NUM_MAX] = {
    {TUYA_ADC_NUM_0, GPIOA_BASE, GPIO_PIN_0, ADC_CH2},
    {TUYA_ADC_NUM_1, GPIOB_BASE, GPIO_PIN_4, ADC_CH6},
};

/**
 * @brief tuya kernel adc init
 *
 * @param[in] port_num: adc port number
 * @param[in] cfg: adc config
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_adc_init(TUYA_ADC_NUM_E port_num, TUYA_ADC_BASE_CFG_T *cfg)
{
#if TKL_ADC_CODE_EN
    uint8_t adc_presc = 0;

    if (port_num>ADC_NUM_MAX-1 || NULL==cfg) {
        return OPRT_INVALID_PARM;
    }

    /* gpio config */
    hal_gpio_pin_mode_set(adc_io_map[port_num].gpio_base, adc_io_map[port_num].ln_pin, GPIO_MODE_ANALOG);

    /* adc init config */
    memset(&__adc_cfg[port_num], 0, sizeof(__adc_cfg[port_num]));
    adc_init_t_def adc_init_cfg = {0};
    adc_init_cfg.adc_ch = adc_io_map[port_num].ln_adc_chan;
    adc_init_cfg.adc_conv_mode = ADC_CONV_MODE_CONTINUE;

    adc_init_cfg.adc_presc = 80;
    hal_adc_init(ADC_BASE, &adc_init_cfg);
    hal_adc_en(ADC_BASE, HAL_ENABLE);
#endif
    return OPRT_OK;
}

/**
 * @brief adc deinit
 *
 * @param[in] port_num: adc port number

 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_adc_deinit(TUYA_ADC_NUM_E port_num)
{
#if TKL_ADC_CODE_EN
    if (port_num>ADC_NUM_MAX-1) {
        return OPRT_INVALID_PARM;
    }

    hal_gpio_pin_mode_set(adc_io_map[port_num].gpio_base, adc_io_map[port_num].ln_pin, GPIO_MODE_DIGITAL);
#endif
    return OPRT_OK;
}

/**
 * @brief get adc width
 *
 * @param[in] port_num: adc port number

 *
 * @return adc width
 */
uint8_t tkl_adc_width_get(TUYA_ADC_NUM_E port_num)
{
    return 12;
}

/**
 * @brief get adc reference voltage
 *
 * @param[in] port_num

 *
 * @return adc reference voltage(bat: mv)
 */
uint32_t tkl_adc_ref_voltage_get(TUYA_ADC_NUM_E port_num)
{
    return 3300;
}

/**
 * @brief adc get temperature
 *
 * @return temperature(bat: 'C)
 */
int32_t tkl_adc_temperature_get(void)
{
#if TKL_ADC_CODE_EN
    int32_t temperature_value = 0;
    adc_init_t_def temp_init;
    uint16_t read_adc = 0;
    int16_t curr_adc = 0;

    if (0 == __temperature_ready) {
        memset(&temp_init, 0, sizeof(adc_init_t_def));
        temp_init.adc_ch        = ADC_CH0;
        temp_init.adc_conv_mode = ADC_CONV_MODE_CONTINUE;
        temp_init.adc_presc     = 0xFF;
        hal_adc_init(ADC_BASE, &temp_init);
        hal_adc_en(ADC_BASE, HAL_ENABLE);
        hal_adc_start_conv(ADC_BASE);
        __temperature_ready=1;
        LOG(LOG_LVL_EMERG, "adc init\r\n");
    }
    while(hal_adc_get_conv_status(ADC_BASE, ADC_CH0) == 0);
    read_adc = hal_adc_get_data(ADC_BASE, ADC_CH0);
    hal_adc_clr_conv_status(ADC_BASE, ADC_CH0);

    curr_adc = (read_adc & 0xFFF);

    return (int32_t)(25 + (curr_adc - 770) / 2.54f);
#endif
    return 0;
}

static inline int32_t __conv_to_4096(uint32_t adc_value)
{
#if TKL_ADC_CODE_EN
    uint32_t voltage = 0;

    if (adc_value > 3350)
        adc_value = 3350;
    else if (adc_value < 225)
        adc_value = 225;

    voltage = ((adc_value - 225) * 775) / 861 + 200;
    return ((voltage << 12) / 3300); // v * 4096 / 3300
#endif
    return 0;
}

/**
 * @brief adc read
 *
 * @param[in] port_num: adc port number
 * @param[out] buff: points to the list of data read from the ADC register
 * @param[in] len:  buff len
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_adc_read_data(TUYA_ADC_NUM_E port_num, int32_t *buff, uint16_t len)
{
#if TKL_ADC_CODE_EN
    uint32_t timeout_cnt = 0;
    uint16_t read_count = 0, adc_value = 0;
    int32_t *p_read_value = buff;

    if ((port_num > ADC_NUM_MAX - 1) || (NULL == buff)) {
        LOG(LOG_LVL_INFO, "OPRT_INVALID_PARM");
        return OPRT_INVALID_PARM;
    }

    hal_adc_start_conv(ADC_BASE);
    for (read_count=0; read_count<len; read_count++) {
        timeout_cnt = 0;
        while(HAL_SET != hal_adc_get_conv_status(ADC_BASE, adc_io_map[port_num].ln_adc_chan)) {
            timeout_cnt++;
            tkl_system_delay(1);
            if (timeout_cnt >= ADC_READ_TIMEOUT) {
                return OPRT_OS_ADAPTER_ADC_TIMEOUT;
            }
        }
        adc_value = hal_adc_get_data(ADC_BASE, adc_io_map[port_num].ln_adc_chan);
        *p_read_value = __conv_to_4096(adc_value);
        hal_adc_clr_conv_status(ADC_BASE, adc_io_map[port_num].ln_adc_chan);
        p_read_value++;
    }


    //hal_adc_stop_conv(ADC_BASE);
#endif
    return OPRT_OK;
}

/**
 * @brief read single channel
 *
 * @param[in] port_num: adc port number
 * @param[in] ch_id: channel id in one adc unit
 * @param[out] buff: convert result buffer
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 *
 */
OPERATE_RET tkl_adc_read_single_channel(TUYA_ADC_NUM_E port_num, uint8_t ch_id, int32_t *data)
{
#if TKL_ADC_CODE_EN
   uint32_t timeout_cnt = 0;
    int32_t adc_convert_value = 0;

    (void) ch_id;
    if (port_num>ADC_NUM_MAX-1 || NULL==data) {
        return OPRT_INVALID_PARM;
    }

    hal_adc_start_conv(ADC_BASE);
    while(HAL_SET != hal_adc_get_conv_status(ADC_BASE, adc_io_map[port_num].ln_adc_chan)) {
        timeout_cnt++;
        tkl_system_delay(1);
        if (timeout_cnt >= ADC_READ_TIMEOUT) {
            return OPRT_OS_ADAPTER_ADC_TIMEOUT;
        }
    }

    adc_convert_value = hal_adc_get_data(ADC_BASE, adc_io_map[port_num].ln_adc_chan);
    *data = __conv_to_4096(adc_convert_value);

    hal_adc_clr_conv_status(ADC_BASE, adc_io_map[port_num].ln_adc_chan);

    //hal_adc_stop_conv(ADC_BASE);
#endif
    return OPRT_OK;
}

/**
 * @brief read voltage
 *
 * @param[in] port_num: adc port number
 * @param[out] buff: points to the list of calculate voltage,bat : mv
 * @param[in] len:  buff len
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 *
 */

OPERATE_RET tkl_adc_read_voltage(TUYA_ADC_NUM_E port_num, int32_t *buff, uint16_t len)
{
#if TKL_ADC_CODE_EN
    OPERATE_RET op_ret = OPRT_OK;
    uint16_t cnv_count = 0;

    op_ret = tkl_adc_read_data(port_num, buff, len);
    if (OPRT_OK != op_ret) {
        return op_ret;
    }

    for (cnv_count=0; cnv_count<len; cnv_count++) {
        buff[cnv_count] = (int32_t)(3300*(buff[cnv_count]*1.0/3413.33));
    }
#endif
    return OPRT_OK;
}

