/**
 * @file tkl_uart.c
 * @brief this file was auto-generated by tuyaos v&v tools, developer can add implements between BEGIN and END
 * 
 * @warning: changes between user 'BEGIN' and 'END' will be keeped when run tuyaos v&v tools
 *           changes in other place will be overwrited and lost
 *
 * @copyright Copyright 2020-2021 Tuya Inc. All Rights Reserved.
 * 
 */

// --- BEGIN: user defines and implements ---
#include "tkl_uart.h"
#include "tuya_error_code.h"
#include "tkl_mutex.h"

#include "proj_config.h"
#include "ln_types.h"
#include "utils/debug/ln_assert.h"
#include "utils/debug/log.h"

#include "hal/hal_uart.h"
#include "hal/hal_gpio.h"

#include "ln882h.h"
#include "base_addr_ln882h.h"
#include "hal_gpio.h"
#include "hal_uart.h"
#include "hal_common.h"
#include "hal_misc.h"
#include "serial_hw.h"
#include "serial.h"
#include "log.h"
#include "rb.h"

#include "reg_sysc_cmp.h"//gpio fullmux
#include "reg_ln_uart.h"//gpio fullmux

#include "tuya_cloud_types.h"
// --- END: user defines and implements ---

#define UART_DEV_NUM            2
#define UART_FIFO_LEN           128

#define UART_HAVE_RX_FIFO       1
#define UART_HAVE_TX_FIFO       0

#define UART_PORT_CHECK(port)                           \
    do {                                                \
        if (TUYA_UART_NUM_0 != port && TUYA_UART_NUM_1 != port)   \
            return OPRT_NOT_SUPPORTED;                  \
    } while(0)

#define UART_DEFAULT_CTRL_BAUD      9600
#define UART_DEFAULT_LOG_BAUD       CFG_UART_BAUDRATE_LOG
#define UART_DEFAULT_WORD_BITS      UART_WORD_LEN_8
#define UART_DEFAULT_STOP_BITS      UART_STOP_BITS_1
#define UART_DEFAULT_PARITY         UART_PARITY_NONE
#define UART_DEFAULT_OVER_SAMPLE    UART_OVER_SAMPL_8

#define __MIN(a, b) ((a) < (b)? (a): (b))
#define __MAX(a, b) ((a) > (b)? (a): (b))

struct uart_dev_s{
    bool                rx_waiting;

#if UART_HAVE_RX_FIFO
    struct ringbuffer   rx_fifo;
#endif // UART_HAVE_RX_FIFO

#if UART_HAVE_TX_FIFO
    struct ringbuffer   tx_fifo;
#endif // UART_HAVE_TX_FIFO
};

typedef struct {
    const uint32_t          uart_base;

    const uint32_t          tx_gpio_base;
    const uint32_t          tx_gpio_pin;
    const uint32_t          tx_gpio_afio;
    const uint32_t          rx_gpio_base;
    const uint32_t          rx_gpio_pin;
    const uint32_t          rx_gpio_afio;

    const uint32_t          irq_num;

    const TUYA_UART_NUM_E   tuya_u_port;

    uart_init_t_def         init;

    bool                    is_opened;
    TUYA_UART_IRQ_CB        rx_isr_cb;
    TUYA_UART_IRQ_CB        tx_isr_cb;

    struct uart_dev_s       dev;
} uart_driver_t;

uart_driver_t g_uart_driver[UART_DEV_NUM] = {
    {
        .uart_base      = UART0_BASE,

        .tx_gpio_base   = GPIOB_BASE,
        .tx_gpio_pin    = GPIO_PIN_9,
        .tx_gpio_afio   = UART0_TX,
        .rx_gpio_base   = GPIOB_BASE,
        .rx_gpio_pin    = GPIO_PIN_8,
        .rx_gpio_afio   = UART0_RX,

        .irq_num        = UART0_IRQn,

        .tuya_u_port    = TUYA_UART_NUM_1,

        .init           =
        {
            .baudrate       = UART_DEFAULT_LOG_BAUD,
            .word_len       = UART_DEFAULT_WORD_BITS,
            .stop_bits      = UART_DEFAULT_STOP_BITS,
            .parity         = UART_DEFAULT_PARITY,
            .over_sampl     = UART_DEFAULT_OVER_SAMPLE,
        },

        .is_opened      = false,
        .rx_isr_cb      = NULL,
        .tx_isr_cb      = NULL,
        .dev = {
            .rx_waiting = false,
        },
    },
    {
        .uart_base      = UART1_BASE,

        .tx_gpio_base   = GPIOA_BASE,
        .tx_gpio_pin    = GPIO_PIN_2,
        .tx_gpio_afio   = UART1_TX,
        .rx_gpio_base   = GPIOA_BASE,
        .rx_gpio_pin    = GPIO_PIN_3,
        .rx_gpio_afio   = UART1_RX,

        .irq_num        = UART1_IRQn,

        .tuya_u_port    = TUYA_UART_NUM_0,

        .init           =
        {
            .baudrate       = UART_DEFAULT_CTRL_BAUD,
            .word_len       = UART_DEFAULT_WORD_BITS,
            .stop_bits      = UART_DEFAULT_STOP_BITS,
            .parity         = UART_DEFAULT_PARITY,
            .over_sampl     = UART_DEFAULT_OVER_SAMPLE,
        },

        .is_opened      = false,
        .rx_isr_cb      = NULL,
        .tx_isr_cb      = NULL,
        .dev            =
        {
            .rx_waiting = false,
        },
    }
};

static inline uart_driver_t *uart_handle_get(TUYA_UART_NUM_E port)
{
    if (port == TUYA_UART_NUM_0)
        return &g_uart_driver[1];
    else if (port == TUYA_UART_NUM_1)
        return &g_uart_driver[0];
    else
        return NULL;
}

static void uart_pin_request(uart_driver_t *uart)
{
    hal_gpio_pin_afio_select(uart->tx_gpio_base, uart->tx_gpio_pin, uart->tx_gpio_afio);
    hal_gpio_pin_afio_en(uart->tx_gpio_base, uart->tx_gpio_pin, HAL_ENABLE);

    // UART1 Enable rx
    if (uart->uart_base == UART1_BASE) {
        hal_gpio_pin_afio_select(uart->rx_gpio_base, uart->rx_gpio_pin, uart->rx_gpio_afio);
        hal_gpio_pin_afio_en(uart->rx_gpio_base, uart->rx_gpio_pin, HAL_ENABLE);
    }
}

static void uart_pin_release(uart_driver_t *uart)
{
    hal_gpio_pin_afio_en(uart->tx_gpio_base, uart->tx_gpio_pin, HAL_DISABLE);

    if (uart->uart_base == UART1_BASE) {
        hal_gpio_pin_afio_en(uart->rx_gpio_base, uart->rx_gpio_pin, HAL_DISABLE);
    }
}

static void uart0_isr_callback(TUYA_UART_NUM_E port)
{
    uart_driver_t *pdrv = &g_uart_driver[0];
    // read reg to clear interrupt
    uint8_t c = hal_uart_recv_data(pdrv->uart_base);
    (void)c;
}

static void uart1_isr_callback(TUYA_UART_NUM_E port)
{
    uart_driver_t *pdrv = &g_uart_driver[1];

    if (hal_uart_it_en_status_get(pdrv->uart_base, USART_IT_RXNE) && \
        hal_uart_flag_get(pdrv->uart_base, USART_FLAG_RXNE)) {

#if UART_HAVE_RX_FIFO
        uint8_t c = hal_uart_recv_data(pdrv->uart_base);
        rb_in(&pdrv->dev.rx_fifo, &c, 1);

        if (pdrv->rx_isr_cb) {
            pdrv->rx_isr_cb(pdrv->tuya_u_port);
        }
#else // !UART_HAVE_RX_FIFO

        if (pdrv->rx_isr_cb) {
            pdrv->rx_isr_cb(pdrv->tuya_u_port);
        } else {
            uint8_t c = hal_uart_recv_data(pdrv->uart_base);
            (void)c;
        }
#endif // !UART_HAVE_RX_FIFO

    }

    if (hal_uart_it_en_status_get(pdrv->uart_base, USART_IT_TXE) && \
        hal_uart_flag_get(pdrv->uart_base, USART_FLAG_TXE)) {

        if(pdrv->tx_isr_cb){
            pdrv->tx_isr_cb(port);
        } else {
            hal_uart_send_data(pdrv->uart_base, 'x');
        }
    }
}

#if (LN_SELF_ATE_TEST_MODE == 0)
void UART0_IRQHandler(void)
{
    uart0_isr_callback(TUYA_UART_NUM_0);
}

void UART1_IRQHandler(void)
{
    uart1_isr_callback(TUYA_UART_NUM_1);
}

void UART2_IRQHandler(void)
{
    // not support, should not get here
}
#endif // LN_SELF_ATE_TEST_MODE == 0

/**
 * @brief uart init
 *
 * @param[in] port_id: uart port id, id index starts at 0
 *                     in linux platform,
 *                         high 16 bits aslo means uart type,
 *                                   it's value must be one of the TUYA_UART_TYPE_E type
 *                         the low 16bit - means uart port id
 *                         you can input like this TUYA_UART_PORT_ID(TUYA_UART_SYS, 2)
 * @param[in] cfg: uart config
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_uart_init(TUYA_UART_NUM_E port_id, TUYA_UART_BASE_CFG_T *cfg)
{
    OPERATE_RET op_ret = OPRT_OK;

    // UART0 / UART1
    UART_PORT_CHECK(port_id);

    uart_driver_t *pdrv = uart_handle_get(port_id);
    if (pdrv == NULL)
        return OPRT_NOT_SUPPORTED;

    // ln882h not support hardware flowctrl
    if (cfg->flowctrl != TUYA_UART_FLOWCTRL_NONE) {
        return OPRT_NOT_SUPPORTED;
    }

    // ln882h only support stopbits: 8 or 9
    if (cfg->databits != TUYA_UART_DATA_LEN_8BIT) {
        return OPRT_INVALID_PARM;
    }
    pdrv->init.word_len   = UART_WORD_LEN_8;

    switch(cfg->parity) {
        case TUYA_UART_PARITY_TYPE_NONE:
            pdrv->init.parity = UART_PARITY_NONE;
            break;
        case TUYA_UART_PARITY_TYPE_ODD:
            pdrv->init.parity = UART_PARITY_ODD;
            break;
        case TUYA_UART_PARITY_TYPE_EVEN:
            pdrv->init.parity = UART_PARITY_EVEN;
            break;
        default:
            return OPRT_INVALID_PARM;
    }

    switch(cfg->stopbits) {
        case TUYA_UART_STOP_LEN_1BIT:
            pdrv->init.stop_bits = UART_STOP_BITS_1;
            break;
        case TUYA_UART_STOP_LEN_2BIT:
            pdrv->init.stop_bits = UART_STOP_BITS_2;
            break;
        case TUYA_UART_STOP_LEN_1_5BIT1:
            pdrv->init.stop_bits = UART_STOP_BITS_1_5;
            break;
        default:
            return OPRT_INVALID_PARM;
    }

    pdrv->init.baudrate   = cfg->baudrate;
    pdrv->init.over_sampl = UART_OVER_SAMPL_8;

    tkl_uart_deinit(port_id);

    pdrv->rx_isr_cb = NULL;
    pdrv->tx_isr_cb = NULL;

    pdrv->dev.rx_waiting = false;

#if UART_HAVE_RX_FIFO
    rb_init(&pdrv->dev.rx_fifo, UART_FIFO_LEN, 1);
#endif // UART_HAVE_RX_FIFO

#if UART_HAVE_TX_FIFO
    rb_init(&pdrv->dev.tx_fifo, UART_FIFO_LEN, 1);
#endif // UART_HAVE_TX_FIFO

    hal_uart_init(pdrv->uart_base, &pdrv->init);

    hal_uart_rx_mode_en(pdrv->uart_base, HAL_ENABLE);
    hal_uart_tx_mode_en(pdrv->uart_base, HAL_ENABLE);
    hal_uart_en(pdrv->uart_base, HAL_ENABLE);

//    hal_uart_it_en(pdrv->uart_base, USART_IT_RXNE);
//    hal_uart_it_en(pdrv->uart_base, USART_IT_TXE);
//    NVIC_EnableIRQ(pdrv->irq_num);

    uart_pin_request(pdrv);

    pdrv->is_opened = true;

    return op_ret;
}

/**
 * @brief uart deinit
 *
 * @param[in] port_id: uart port id, id index starts at 0
 *                     in linux platform,
 *                         high 16 bits aslo means uart type,
 *                                   it's value must be one of the TUYA_UART_TYPE_E type
 *                         the low 16bit - means uart port id
 *                         you can input like this TUYA_UART_PORT_ID(TUYA_UART_SYS, 2)
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_uart_deinit(TUYA_UART_NUM_E port_id)
{
    OPERATE_RET op_ret = OPRT_OK;
    UART_PORT_CHECK(port_id);

    uart_driver_t *pdrv = uart_handle_get(port_id);
    if (pdrv == NULL) {
        return OPRT_NOT_SUPPORTED;
    }

    hal_uart_deinit(pdrv->uart_base);

    hal_uart_it_disable(pdrv->uart_base, USART_IT_TXE);
    hal_uart_it_disable(pdrv->uart_base, USART_IT_RXNE);

    NVIC_ClearPendingIRQ(pdrv->irq_num);
    NVIC_DisableIRQ(pdrv->irq_num);
    uart_pin_release(pdrv);

    pdrv->rx_isr_cb = NULL;

    if (pdrv->is_opened == true) {

        pdrv->is_opened = false;

#if UART_HAVE_RX_FIFO
        rb_deinit(&pdrv->dev.rx_fifo);
#endif // UART_HAVE_RX_FIFO

#if UART_HAVE_TX_FIFO
        rb_deinit(&pdrv->dev.tx_fifo);
#endif // UART_HAVE_TX_FIFO
    }

    return op_ret;
}

/**
 * @brief uart write data
 *
 * @param[in] port_id: uart port id, id index starts at 0
 *                     in linux platform,
 *                         high 16 bits aslo means uart type,
 *                                   it's value must be one of the TUYA_UART_TYPE_E type
 *                         the low 16bit - means uart port id
 *                         you can input like this TUYA_UART_PORT_ID(TUYA_UART_SYS, 2)
 * @param[in] data: write buff
 * @param[in] len:  buff len
 *
 * @return return > 0: number of data written; return <= 0: write errror
 */
int tkl_uart_write(TUYA_UART_NUM_E port_id, void *buff, uint16_t len)
{
    int i;
    uart_driver_t *pdrv = uart_handle_get(port_id);
    if (pdrv == NULL)
        return OPRT_NOT_SUPPORTED;

    if (buff == NULL || len == 0)
        return 0;

    if (pdrv->is_opened == true) {
        for (i = 0; i < len; i++) {
            while (hal_uart_flag_get(pdrv->uart_base, USART_FLAG_TXE) != HAL_SET);
            hal_uart_send_data(pdrv->uart_base, *(uint8_t *)(buff + i));
        }
        return i;
    }

    return 0;
    // --- END: user implements ---
}

/**
 * @brief enable uart rx interrupt and regist interrupt callback
 *
 * @param[in] port_id: uart port id, id index starts at 0
 *                     in linux platform,
 *                         high 16 bits aslo means uart type,
 *                                   it's value must be one of the TUYA_UART_TYPE_E type
 *                         the low 16bit - means uart port id
 *                         you can input like this TUYA_UART_PORT_ID(TUYA_UART_SYS, 2)
 * @param[in] rx_cb: receive callback
 *
 * @return none
 */
void tkl_uart_rx_irq_cb_reg(TUYA_UART_NUM_E port_id, TUYA_UART_IRQ_CB rx_cb)
{
    uart_driver_t *pdrv = uart_handle_get(port_id);
    if (pdrv == NULL)
        return;

    if ((TUYA_UART_NUM_0 != port_id) && (TUYA_UART_NUM_1 != port_id))
        return;

    pdrv->rx_isr_cb = rx_cb;

    hal_uart_it_en(pdrv->uart_base, USART_IT_RXNE);
    NVIC_EnableIRQ(pdrv->irq_num);

    return;
}

/**
 * @brief regist uart tx interrupt callback
 * If this function is called, it indicates that the data is sent asynchronously through interrupt,
 * and then write is invoked to initiate asynchronous transmission.
 *
 * @param[in] port_id: uart port id, id index starts at 0
 *                     in linux platform,
 *                         high 16 bits aslo means uart type,
 *                                   it's value must be one of the TUYA_UART_TYPE_E type
 *                         the low 16bit - means uart port id
 *                         you can input like this TUYA_UART_PORT_ID(TUYA_UART_SYS, 2)
 * @param[in] rx_cb: receive callback
 *
 * @return none
 */
void tkl_uart_tx_irq_cb_reg(TUYA_UART_NUM_E port_id, TUYA_UART_IRQ_CB tx_cb)
{
    // UNSUPPORTED
    uart_driver_t *pdrv = uart_handle_get(port_id);
    if (pdrv == NULL)
        return;

    if ((TUYA_UART_NUM_0 != port_id) && (TUYA_UART_NUM_1 != port_id))
        return;

    // TODO NOW Not support
//    pdrv->tx_isr_cb = tx_cb;

//    hal_uart_it_en(pdrv->uart_base, USART_IT_TXE);
//    NVIC_EnableIRQ(pdrv->irq_num);

    return;
}

/**
 * @brief uart read data
 *
 * @param[in] port_id: uart port id, id index starts at 0
 *                     in linux platform,
 *                         high 16 bits aslo means uart type,
 *                                   it's value must be one of the TUYA_UART_TYPE_E type
 *                         the low 16bit - means uart port id
 *                         you can input like this TUYA_UART_PORT_ID(TUYA_UART_SYS, 2)
 * @param[out] data: read data
 * @param[in] len:  buff len
 *
 * @return return >= 0: number of data read; return < 0: read errror
 */
int tkl_uart_read(TUYA_UART_NUM_E port_id, void *buff, uint16_t len)
{
    uart_driver_t *pdrv = uart_handle_get(port_id);
    if (pdrv == NULL)
        return OPRT_NOT_SUPPORTED;

    UART_PORT_CHECK(port_id);

    if ((buff == NULL) || (len == 0))
        return 0;

#if UART_HAVE_RX_FIFO
    if (rb_is_empty(&pdrv->dev.rx_fifo))
        return 0;

    uint16_t tmp = rb_avail(&pdrv->dev.rx_fifo);
    uint16_t l = rb_avail(&pdrv->dev.rx_fifo);
    l = __MIN(l, len);
    rb_out(&pdrv->dev.rx_fifo, (uint8_t *)buff, l);
    return l;
#else // !UART_HAVE_RX_FIFO
    *(uint8_t *)buff = hal_uart_recv_data(pdrv->uart_base);
    return 1;
#endif // !UART_HAVE_RX_FIFO
}

/**
 * @brief set uart transmit interrupt status
 *
 * @param[in] port_id: uart port id, id index starts at 0
 *                     in linux platform,
 *                         high 16 bits aslo means uart type,
 *                                   it's value must be one of the TUYA_UART_TYPE_E type
 *                         the low 16bit - means uart port id
 *                         you can input like this TUYA_UART_PORT_ID(TUYA_UART_SYS, 2)
 * @param[in] enable: TRUE-enalbe tx int, FALSE-disable tx int
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_uart_set_tx_int(TUYA_UART_NUM_E port_id, BOOL_T enable)
{
    OPERATE_RET op_ret = OPRT_NOT_SUPPORTED;

    UART_PORT_CHECK(port_id);


    return op_ret;
}

/**
 * @brief set uart receive flowcontrol
 *
 * @param[in] port_id: uart port id, id index starts at 0
 *                     in linux platform,
 *                         high 16 bits aslo means uart type,
 *                                   it's value must be one of the TUYA_UART_TYPE_E type
 *                         the low 16bit - means uart port id
 *                         you can input like this TUYA_UART_PORT_ID(TUYA_UART_SYS, 2)
 * @param[in] enable: TRUE-enalbe rx flowcontrol, FALSE-disable rx flowcontrol
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_uart_set_rx_flowctrl(TUYA_UART_NUM_E port_id, BOOL_T enable)
{
    OPERATE_RET op_ret = OPRT_NOT_SUPPORTED;

    UART_PORT_CHECK(port_id);

    return op_ret;
}

/**
 * @brief wait for uart data
 *
 * @param[in] port_id: uart port id, id index starts at 0
 *                     in linux platform,
 *                         high 16 bits aslo means uart type,
 *                                   it's value must be one of the TUYA_UART_TYPE_E type
 *                         the low 16bit - means uart port id
 *                         you can input like this TUYA_UART_PORT_ID(TUYA_UART_SYS, 2)
 * @param[in] timeout_ms: the max wait time, unit is millisecond
 *                        -1 : block indefinitely
 *                        0  : non-block
 *                        >0 : timeout in milliseconds
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_uart_wait_for_data(TUYA_UART_NUM_E port_id, int timeout_ms)
{
    OPERATE_RET op_ret = OPRT_NOT_SUPPORTED;

    UART_PORT_CHECK(port_id);

    return op_ret;
}

/**
 * @brief uart control
 *
 * @param[in] uart refer to tuya_uart_t
 * @param[in] cmd control command
 * @param[in] arg command argument
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_uart_ioctl(TUYA_UART_NUM_E port_id, uint32_t cmd, void *arg)
{
   OPERATE_RET op_ret = OPRT_NOT_SUPPORTED;

    UART_PORT_CHECK(port_id);

    return op_ret;
}

