/**
 * @file tkl_wifi.c
 * @brief this file was auto-generated by tuyaos v&v tools, developer can add implements between BEGIN and END
 *
 * @warning: changes between user 'BEGIN' and 'END' will be keeped when run tuyaos v&v tools
 *           changes in other place will be overwrited and lost
 *
 * @copyright Copyright 2020-2021 Tuya Inc. All Rights Reserved.
 *
 */

// --- BEGIN: user defines and implements ---
#include "tkl_wifi.h"
#include "tuya_error_code.h"
#include "tkl_memory.h"
#include "tkl_system.h"
#include "tkl_semaphore.h"

#include "ln_netif/ln_ethernetif.h"
#include "wifi.h"
#include "wifi_port.h"
#include "wifi_manager.h"
#include "ln_kv_api.h"
#include "ln_psk_calc.h"
#include "ln_nvds.h"
#include "ln_utils.h"
#include "lwip/ethernetif.h"

#include "lwip/inet.h"
#include "lwip/netif.h"
#include "utils/debug/log.h"
#include "utils/system_parameter.h"
#include "utils/power_mgmt/ln_pm.h"
#include "hal/hal_adc.h"

#include "tkl_semaphore.h"
#include "tkl_system.h"

#if defined(ENABLE_BLUETOOTH) && (ENABLE_BLUETOOTH == 1)
#include "tkl_bluetooth_def.h"
#endif

#include "freertos_common.h"
#include "freertos_mutex.h"
#include "freertos_semaphore.h"
#include "freertos_timer.h"
// --- END: user defines and implements ---

#define CONNECTED_SCAN_TIMES    (6)
#define DEFAULT_SCAN_TIMES      (1)
#define SCAN_TIMEOUT            (1500)

#define TUYA_PSK_VAL_LEN        (40)
#undef  TUYA_PSK_KV_INFO
#define TUYA_PSK_KV_INFO                  ((const char *)"ty_ada_psk")

#define WAIT_STA_READY_TIMEOUT  0x00FF


#undef  UNUSED
#define UNUSED(x) (void)x

#define TUYA_PSK_INFO_STORE_NUM           (1)  // now, only support 1
#define TUYA_PSK_VAL_LEN                  (40)
#define WIFI_PARAMS_GET()                 (&s_tuya_wifi_params)

#define TY_ADA_WIFI_PS_MODE           (WIFI_MAX_POWERSAVE) // used mode when power-save enabled
#define TY_ADA_WIFI_DEFAULT_PS_MODE   (WIFI_MAX_POWERSAVE)  // default mode

typedef struct {
    uint8_t ssid[SSID_MAX_LEN];
    uint8_t pwd[PASSWORD_MAX_LEN];
    uint8_t pwd_len;
    uint8_t psk[TUYA_PSK_VAL_LEN];
    uint8_t channel;
} tuya_hal_wifi_psk_info_t;

typedef struct {
    int                 ty_wifi_started;
    WF_WK_MD_E          mode;
    COUNTRY_CODE_E      ccode;
    sta_ps_mode_t       ps_mode;
    OS_Semaphore_t      scan_comp;
    int                 wait_scan;
    int                 ty_wifi_status;
    WIFI_REV_MGNT_CB    mgnt_recv_cb;
    WIFI_REV_MGNT_CB    mgnt_recv_cb_backup;
    SNIFFER_CALLBACK    sniffer_cb;
    int                 is_sniffer_conf;
    WIFI_EVENT_CB       tkl_wifi_event_callback;
} tuya_hal_wifi_params_t;

static tuya_hal_wifi_params_t s_tuya_wifi_params = {
    .ty_wifi_started = 0,
    .mode = WWM_STATION,
    .ccode = COUNTRY_CODE_CN,
    .ps_mode = TY_ADA_WIFI_DEFAULT_PS_MODE,
    .is_sniffer_conf = 0,
    .mgnt_recv_cb = NULL,
    .mgnt_recv_cb_backup = NULL,
};

static OS_Timer_t s_wifi_temp_cal_timer = {0};
static TKL_SEM_HANDLE s_sem_scan = NULL;
static TKL_SEM_HANDLE ln_ap_scan_sem = NULL;
static void local_lp_mode_set(const BOOL_T enable);

static int tuya_hal_wifi_get_country_code(COUNTRY_CODE_E *ccode)
{
    tuya_hal_wifi_params_t *wifi_params = WIFI_PARAMS_GET();

    if(NULL == ccode) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }
    *ccode = wifi_params->ccode;

    return OPRT_OK;
}

static void ap_startup_cb(void)
{
    LOG(LOG_LVL_INFO, "%s %d, wifi softap up\r\n", __func__, __LINE__);
    netdev_set_state(NETIF_IDX_AP, NETDEV_UP);
}

static void ty_wifi_recv_mgnt_cb(uint8_t *buf, uint32_t len)
{
    tuya_hal_wifi_params_t *wifi_params = WIFI_PARAMS_GET();

//    LOG(LOG_LVL_ERROR, "[%s] len:%d, mgnt cb: %x, %x %x\r\n", __func__,
//            len, wifi_params->mgnt_recv_cb, buf[len-1], buf[len-2]);
//    hexdump(LOG_LVL_INFO, "wifi recv mgnt", buf + 10, 16);
    if (wifi_params->mgnt_recv_cb) {
        wifi_params->mgnt_recv_cb(buf, len);
    }
}

static void tuya_hal_wifi_sniffer_handler(void *buf, uint16_t len, wifi_pkt_type_t pkt_type, int8_t rssi_db)
{
    tuya_hal_wifi_params_t *wifi_params = WIFI_PARAMS_GET();
    const uint8_t * ppkt = (uint8_t *)buf;

    UNUSED(pkt_type);

//    if (pkt_type == WIFI_PKT_TYPE_MGMT && wifi_params->mgnt_recv_cb) {
//        LOG(LOG_LVL_DEBUG, "[%s:%d] mgnt recv cb\r\n", __func__, __LINE__);
//
//        // typedef void (*WIFI_REV_MGNT_CB)(uint8_t *buf, uint32_t len);
//        wifi_params->mgnt_recv_cb(&ppkt[0], len);
//    }

    if (wifi_params->sniffer_cb) {
        // LOG(LOG_LVL_DEBUG, "[%s:%d] sniffer recv cb\r\n", __func__, __LINE__);
        wifi_params->sniffer_cb((const uint8_t *)&ppkt[0], (const uint16_t)len, (const int8_t)rssi_db);
    }
}

static int tuya_hal_wifi_psk_update(const tuya_hal_wifi_psk_info_t * psk_info)
{
    int ret = 0;
    ret = ln_kv_set(TUYA_PSK_KV_INFO, psk_info, sizeof(tuya_hal_wifi_psk_info_t));
    if (ret != KV_ERR_NONE)
    {
        LOG(LOG_LVL_ERROR, "psk update / kv set failed: %d\r\n", ret);
        return -1;
    }
    return 0;
}

static int tuya_hal_wifi_psk_get(tuya_hal_wifi_psk_info_t * psk_info)
{
    int ret = 0;
    size_t v_len = 0;
    if (psk_info == NULL) {
        return -1;
    }

    memset(psk_info, 0x0, sizeof(tuya_hal_wifi_psk_info_t));
    ret = ln_kv_get(TUYA_PSK_KV_INFO, psk_info, sizeof(tuya_hal_wifi_psk_info_t), &v_len);
    if (ret != KV_ERR_NONE)
    {
        LOG(LOG_LVL_ERROR, "psk info / kv get failed: %d\r\n", ret);
        return -1;
    }
    return 0;
}

static void __tkl_wifi_scan_complete_cb(void *arg)
{
    UNUSED(arg);
    LOG(LOG_LVL_INFO, "scan complete\r\n");
    tkl_semaphore_post(s_sem_scan);
}

static void __tkl_wifi_disconnect_cb(void *arg)
{
    tuya_hal_wifi_params_t *wifi_params = WIFI_PARAMS_GET();
    UNUSED(arg);

    LOG(LOG_LVL_INFO, " %s %d\r\n", __func__, __LINE__);
    if (wifi_params->tkl_wifi_event_callback != NULL) {
        wifi_params->tkl_wifi_event_callback(WFE_DISCONNECTED, NULL);
    }


    wifi_params->ty_wifi_status = WSS_IDLE;
    wifi_set_allow_cpu_sleep_flag(0);
}

static void tuya_wifi_get_ip_cb(struct netif *nif)
{
    tuya_hal_wifi_psk_info_t psk_info = {0};
    tuya_hal_wifi_params_t *wifi_params = WIFI_PARAMS_GET();
    UNUSED(nif);


    if (tuya_hal_wifi_psk_get(&psk_info) == 0) {
        //update channel
        uint8_t chan = 0;
        wifi_get_channel(&chan);
        if (psk_info.channel != chan) {
            psk_info.channel = chan;
            if (0 != tuya_hal_wifi_psk_update((const tuya_hal_wifi_psk_info_t *)&psk_info)) {
                LOG(LOG_LVL_ERROR, "update wifi channel failed!\r\n");
            }
            LOG(LOG_LVL_ERROR, "update wifi channel %d\r\n", psk_info.channel);
        }
    }

    wifi_params->ty_wifi_status = WSS_GOT_IP;
    if (wifi_params->tkl_wifi_event_callback != NULL) {
        wifi_params->tkl_wifi_event_callback(WFE_CONNECTED, NULL);
    }

    *(volatile int *)(0x400121F8) = 0x003F; //wifi first
    //had got ip, allow low power mode
    wifi_set_allow_cpu_sleep_flag(1);
    LOG(LOG_LVL_INFO, "tuya_wifi_get_ip_cb\r\n");
}

static void wifi_temp_calibrate_timer_cb(void *arg)
{
    uint16_t adc_val = 0;
    int16_t curr_adc = 0;
    wifi_sta_status_t status;
    int8_t rssi = -128;
    volatile uint32_t *cap_reg_val = (uint32_t *)0x40100014;
    volatile uint32_t *awo_sys_pll_reg_val = (uint32_t *)0x40100074;
    LN_UNUSED(arg);

    extern uint16_t rf_read_ln882x(uint8_t page_id, uint8_t addr);

    adc_val = drv_adc_read(ADC_CH0);
    wifi_do_temp_cal_period(adc_val);

    curr_adc = (adc_val & 0xFFF);
    static volatile uint32_t cnt = 0;
    extern int8_t get_rssi(void);
    cnt++;

    rssi = get_rssi();
    wifi_get_sta_status(&status);

    if (status != WIFI_STA_STATUS_CONNECTED) {
        rssi = -128;
    }
#if 1
    if ((cnt % 60) == 0) {
        LOG(LOG_LVL_INFO,
                "adc raw: %4d, temp_IC: %d, cap:0x%08X, rf43:0x%04X"
                ", reg74:0x%04X\r\n",
                curr_adc, (int16_t)(25 + (curr_adc - 770) / 2.54f),
                (uint32_t)(*cap_reg_val), rf_read_ln882x(0, 0x43),
                (uint32_t)(*awo_sys_pll_reg_val));
    }
#endif
}

static int tuya_hal_wifi_start(WF_WK_MD_E mode)
{
    wifi_mode_t  ln_wifi_mode;
    tuya_hal_wifi_params_t *wifi_params = WIFI_PARAMS_GET();
    wifi_params->mode = mode;
    static uint8_t is_wifi_hw_ready = 0;

    LOG(LOG_LVL_INFO, "adapt wifi start <m:%d>, hw_ready:%d\r\n", mode, is_wifi_hw_ready);
    if (is_wifi_hw_ready == 0) {
        LOG(LOG_LVL_INFO, "start rf preprocess and image cal\r\n");
        // rf preprocess,img cal
        wifi_rf_preprocess();    // time consuming 80ms
        wifi_rf_image_cal();     // time consuming 156ms
        *(volatile int *)(0x40012034) = 0x540;

        // init wifi
        wifi_init();
        wifi_manager_init();     // Creat wifi manager task

        // Start wifi temperature calibrate
        {
            int8_t cap_comp = 0;

            if (NVDS_ERR_OK == ln_nvds_get_xtal_comp_val((uint8_t *)&cap_comp)) {
                if ((uint8_t)cap_comp == 0xFF) {
                    cap_comp = 0;
                }
            }

            drv_adc_init();
            wifi_temp_cal_init(drv_adc_read(ADC_CH0), cap_comp);
            LOG(LOG_LVL_INFO, "XTAL CAP VAL:%d.\r\n",cap_comp);
            if (LN_OS_OK != OS_TimerCreate(&s_wifi_temp_cal_timer, OS_TIMER_PERIODIC,
                    wifi_temp_calibrate_timer_cb, NULL, 1000)) {
                LOG(LOG_LVL_ERROR, "create wifi temp calibrate timer failed.\r\n");
            } else {
                OS_TimerStart(&s_wifi_temp_cal_timer);
            }
        }
        is_wifi_hw_ready = 1;
    }

    switch(mode)
    {
        case WWM_STATION:
            ln_wifi_mode=WIFI_MODE_STATION;
            break;
        case WWM_SOFTAP:
            ln_wifi_mode=WIFI_MODE_AP;
            break;
        case WWM_POWERDOWN:
            // if(0 != wifi_station_set_powersave(WIFI_MAX_POWERSAVE)){
            //     return OPRT_OS_ADAPTER_WORKMODE_SET_FAILED;
            // }else{
                return OPRT_OK;
            // }
            #warning "TODO: WWM_POWERDOWN"
        case WWM_STATIONAP:
            // ln_wifi_mode = WIFI_MODE_AP_STATION;
            // break;
        case WWM_SNIFFER:
        default:
            ln_wifi_mode = WIFI_MODE_STATION;
            break;
    }

    if (0 != wifi_params->ty_wifi_started) {
        goto __ok;
    }

    LOG(LOG_LVL_INFO, "wifi stop\r\n");
    wifi_stop();

    if (ln_wifi_mode == WIFI_MODE_STATION)
    {
        uint8_t mac_addr[MAC_ADDRESS_LEN];
        sysparam_sta_mac_get(mac_addr);
        //netdev_set_state(NETIF_IDX_STA, NETDEV_DOWN);
        netdev_set_mac_addr(NETIF_IDX_STA, mac_addr);
        netdev_set_active(NETIF_IDX_STA);

        wifi_manager_reg_event_callback(WIFI_MGR_EVENT_STA_DISCONNECTED, __tkl_wifi_disconnect_cb);

        netdev_get_ip_cb_set(tuya_wifi_get_ip_cb);
        LOG(LOG_LVL_INFO, "wifi sta start ps_mode = %d\r\n", wifi_params->ps_mode);
        wifi_sta_start(mac_addr, wifi_params->ps_mode);
    }
    else
    {
        uint8_t mac_addr[MAC_ADDRESS_LEN];
        sysparam_softap_mac_get(mac_addr);
        wifi_softap_cfg_t ap_cfg = {
            .ssid            = "temp",
            .pwd             = "",
            .bssid           = mac_addr,
            .ext_cfg = {
                .channel         = 6,
                .authmode        = WIFI_AUTH_OPEN,
                .ssid_hidden     = 1,
                .beacon_interval = 100,
                .psk_value = NULL,
            }
        };

        ap_cfg.ext_cfg.psk_value = NULL;

        //netdev_set_state(NETIF_IDX_AP, NETDEV_DOWN);
        netdev_set_active(NETIF_IDX_AP);

        wifi_manager_reg_event_callback(WIFI_MGR_EVENT_SOFTAP_STARTUP, &ap_startup_cb);
        LOG(LOG_LVL_INFO, "wifi softap start\r\n");
        wifi_softap_start(&ap_cfg);
    }

    wifi_params->ty_wifi_started = 1;

__ok:
    return OPRT_OK;
}

OPERATE_RET __tkl_wifi_all_ap_scan(AP_IF_S **ap_ary, uint32_t *num)
{
    wifi_mode_t mode;
    int ret = OPRT_OK;

    tuya_hal_wifi_params_t *wifi_params = WIFI_PARAMS_GET();

    if(NULL == ap_ary || NULL == num) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }

    if (WIFI_MODE_STATION != (mode = wifi_current_mode_get()))
    {
        return OPRT_OS_ADAPTER_COM_ERROR;
    }

    if (WWM_STATION != wifi_params->mode)
    {
        LOG(LOG_LVL_ERROR, "Pattern does not match! mode:%d; param->mode:%d\r\n",
                mode, wifi_params->mode);
        return OPRT_OS_ADAPTER_COM_ERROR;
    }

    if (0 == wifi_params->ty_wifi_started) {
        LOG(LOG_LVL_DEBUG, "[%s:%d] wifi is not started\r\n", __func__, __LINE__);
        tuya_hal_wifi_start(WWM_STATION);
    }

    {
        //1. creat sem, reg scan complete callback.
        if (0 != tkl_semaphore_create_init(&s_sem_scan, 0, 1)) {
            return OPRT_OS_ADAPTER_SEM_CREAT_FAILED;
        }

        wifi_manager_reg_event_callback(WIFI_MGR_EVENT_STA_SCAN_COMPLETE, &__tkl_wifi_scan_complete_cb);

        //2. start scan, wait scan complete
        wifi_scan_cfg_t   scan_cfg   = {0,};
        sysparam_sta_scan_cfg_get(&scan_cfg);

        scan_cfg.scan_time = 120;
        wifi_sta_scan(&scan_cfg);
        LOG(LOG_LVL_INFO, "--- %d wait scan\r\n", __LINE__);
        tkl_semaphore_wait(s_sem_scan, TKL_SEM_WAIT_FOREVER);

        //3. scan complete,output ap list.
        {
            ln_list_t *list;
            uint8_t node_count = 0;
            ap_info_node_t *pnode;
            AP_IF_S *ap_info = NULL, *ap_itr = NULL;

            wifi_manager_ap_list_update_enable(LN_FALSE);
            wifi_manager_get_ap_list(&list, &node_count);

            LOG(LOG_LVL_INFO, "AP cnt:%d\r\n", node_count);
            if (node_count <= 0) {
                ret = OPRT_OS_ADAPTER_AP_NOT_FOUND;
                goto __finish;
            }

            // malloc memory to store ap list,and free in tuya_hal_wifi_release_ap()
            ap_info = tkl_system_malloc(sizeof(AP_IF_S) * node_count);
            if(NULL == ap_info) {
                ret = OPRT_OS_ADAPTER_MALLOC_FAILED;
                goto __finish;
            }

            ap_itr = ap_info;
            memset(ap_info, 0, (sizeof(AP_IF_S) * node_count));

            LN_LIST_FOR_EACH_ENTRY(pnode, ap_info_node_t, list, list)
            {
                ap_info_t *info = &pnode->info;

                ap_itr->channel = info->channel;
                ap_itr->rssi    = info->rssi;
                memcpy(ap_itr->bssid, info->bssid, BSSID_LEN);
                memcpy(ap_itr->ssid,  info->ssid,  WIFI_SSID_LEN + 1);
                ap_itr->ssid[WIFI_SSID_LEN] = '\0';

                ap_itr->s_len = strlen((const char *)ap_itr->ssid);
                ap_itr++;
            }

__finish:
            *num = node_count;
            *ap_ary = ap_info;
            wifi_manager_ap_list_update_enable(LN_TRUE);
        }

        //4. delete sem, callback
        wifi_manager_reg_event_callback(WIFI_MGR_EVENT_STA_SCAN_COMPLETE, NULL);
        tkl_semaphore_release(s_sem_scan);
        wifi_manager_cleanup_scan_results();
        s_sem_scan = NULL;
    }

    return ret;
}

OPERATE_RET __tkl_wifi_assign_ap_scan(const int8_t *ssid, AP_IF_S **ap)
{
    int ret = OPRT_OK;
    wifi_mode_t mode;

    tuya_hal_wifi_params_t *wifi_params = WIFI_PARAMS_GET();

    if(NULL == ssid || NULL == ap) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }

    if (WIFI_MODE_STATION != (mode = wifi_current_mode_get()))
    {
        return OPRT_OS_ADAPTER_COM_ERROR;
    }

    if (WWM_STATION != wifi_params->mode)
    {
        LOG(LOG_LVL_ERROR, "Pattern does not match! mode:%d; param->mode:%d\r\n",
                mode, wifi_params->mode);
        return OPRT_OS_ADAPTER_COM_ERROR;
    }

    if (0 == wifi_params->ty_wifi_started) {
        LOG(LOG_LVL_DEBUG, "[%s:%d] wifi is not started\r\n", __func__, __LINE__);
        tuya_hal_wifi_start(WWM_STATION);
    }

    {
        //1. creat sem, reg scan complete callback.
        if (0 != tkl_semaphore_create_init(&s_sem_scan, 0, 1)) {
            return OPRT_OS_ADAPTER_SEM_CREAT_FAILED;
        }

        wifi_manager_reg_event_callback(WIFI_MGR_EVENT_STA_SCAN_COMPLETE, &__tkl_wifi_scan_complete_cb);

        //2. start scan, wait scan complete
        wifi_scan_cfg_t   scan_cfg   = {0,};
        sysparam_sta_scan_cfg_get(&scan_cfg);

        LOG(LOG_LVL_INFO, "--- %d start scan %s\r\n", __LINE__, ssid);
        scan_cfg.scan_time = 120;
        wifi_sta_scan(&scan_cfg);
        tkl_semaphore_wait(s_sem_scan, TKL_SEM_WAIT_FOREVER);

        //3. scan complete,output ap list.
        {
            ln_list_t *list;
            uint8_t node_count = 0;
            ap_info_node_t *pnode;
            AP_IF_S *ap_info = NULL;

            wifi_manager_ap_list_update_enable(LN_FALSE);
            wifi_manager_get_ap_list(&list, &node_count);

            LOG(LOG_LVL_INFO, "AP cnt:%d\r\n", node_count);

            if (node_count <= 0) {
                ret = OPRT_OS_ADAPTER_AP_NOT_FOUND;
                goto __finish;
            }

            LN_LIST_FOR_EACH_ENTRY(pnode, ap_info_node_t, list, list)
            {
                ap_info_t *info = &pnode->info;

                if ((memcmp(ssid, info->ssid, strlen((const char *)ssid)) == 0) &&
                    (strlen((const char *)ssid) == strlen((const char *)info->ssid)))
                {
                    // malloc memory to store ap list,and free in tuya_hal_wifi_release_ap()
                    ap_info = tkl_system_malloc(sizeof(AP_IF_S));
                    if(NULL == ap_info) {
                        ret = OPRT_OS_ADAPTER_MALLOC_FAILED;
                        goto __finish;
                    }

                    memset(ap_info, 0, (sizeof(AP_IF_S)));

                    ap_info->channel = info->channel;
                    ap_info->rssi    = info->rssi;
                    ap_info->s_len   = strlen((const char *)ssid);
                    memcpy(ap_info->bssid, info->bssid, BSSID_LEN);
                    memcpy(ap_info->ssid,  info->ssid,  ap_info->s_len);
                    ap_info->ssid[ap_info->s_len] = '\0';
                    goto __finish;
                }
            }

__finish:
            if (NULL == ap_info)
            {
                ret = OPRT_OS_ADAPTER_AP_NOT_FOUND;
            }
            *ap = ap_info;
            wifi_manager_ap_list_update_enable(LN_TRUE);
        }

        //4. delete sem, callback
        wifi_manager_reg_event_callback(WIFI_MGR_EVENT_STA_SCAN_COMPLETE, NULL);
        tkl_semaphore_release(s_sem_scan);
        wifi_manager_cleanup_scan_results();
        s_sem_scan = NULL;
    }

    return ret;
}


/**
 * @brief set wifi station work status changed callback
 *
 * @param[in]      cb        the wifi station work status changed callback
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_init(WIFI_EVENT_CB cb)
{
    tuya_hal_wifi_params_t *wifi_params = WIFI_PARAMS_GET();

    wifi_params->tkl_wifi_event_callback = cb;

    return OPRT_OK;
}

static void ln_wifi_ap_scan_cpl_cb(void *arg)
{
    // release semaphore
    tkl_semaphore_post(ln_ap_scan_sem);
}

static OPERATE_RET __ln_ap_scan(wifi_scan_cfg_t *scan_cfg, const int8_t *ssid, AP_IF_S **ap_ary)
{
    OPERATE_RET ret = OPRT_OK;
    ap_info_t *ap_info = NULL;
    AP_IF_S *assigned_ap_info = NULL;
    int ap_info_items = 40;
    ap_info_t *ap_info_rst = NULL;
    int ap_info_rst_items = 0;

    tkl_semaphore_create_init(&ln_ap_scan_sem, 0, 1);
    if (!ln_ap_scan_sem) {
        ret = OPRT_OS_ADAPTER_COM_ERROR;
        goto __exit;
    }

    ap_info = OS_Malloc(ap_info_items * sizeof(ap_info_t));
    if (!ap_info) {
        ret = OPRT_OS_ADAPTER_MALLOC_FAILED;
        goto __exit;
    }

    wifi_softap_scan(scan_cfg, ap_info, ap_info_items, ln_wifi_ap_scan_cpl_cb);

    // wait scan cpl semaphore
    tkl_semaphore_wait(ln_ap_scan_sem, TKL_SEM_WAIT_FOREVER);
    tkl_semaphore_release(ln_ap_scan_sem);

    // get scan result
    wifi_softap_scan_results_get(&ap_info_rst, &ap_info_rst_items);
    LOG(LOG_LVL_INFO, "ap scan results:%d\r\n", ap_info_rst_items);

    if (!ap_info_rst) {
        ret = OPRT_OS_ADAPTER_COM_ERROR;
        goto __exit;
    }

    LOG(LOG_LVL_INFO, "%10.10s   %19.16s   %4.4s   %2.2s   %4.4s\r\n",
        "ssid", "bssid", "rssi", "ch", "auth");

    for (int i = 0; i < ap_info_rst_items; i++) {
        LOG(LOG_LVL_INFO, "%10.10s   [%02x:%02x:%02x:%02x:%02x:%02x]"
            "   %4d   %2d   %4d\r\n",
            ap_info_rst[i].ssid, ap_info_rst[i].bssid[0],
            ap_info_rst[i].bssid[1], ap_info_rst[i].bssid[2],
            ap_info_rst[i].bssid[3], ap_info_rst[i].bssid[4],
            ap_info_rst[i].bssid[5], ap_info_rst[i].rssi,
            ap_info_rst[i].channel, ap_info_rst[i].authmode);

        if ((memcmp(ssid, ap_info_rst[i].ssid, strlen((const char *)ssid)) == 0) &&
            (strlen((const char *)ssid) == strlen((const char *)ap_info_rst[i].ssid))) {
            // malloc memory to store ap list,and free in tuya_hal_wifi_release_ap()
            assigned_ap_info = tkl_system_malloc(sizeof(AP_IF_S));
            if(NULL == assigned_ap_info) {
                ret = OPRT_OS_ADAPTER_MALLOC_FAILED;
                goto __exit;
            }

            memset(assigned_ap_info, 0, sizeof(AP_IF_S));

            assigned_ap_info->channel = ap_info_rst[i].channel;
            assigned_ap_info->rssi    = ap_info_rst[i].rssi;
            assigned_ap_info->s_len   = strlen((const char *)ssid);
            memcpy(assigned_ap_info->bssid, ap_info_rst[i].bssid, BSSID_LEN);
            memcpy(assigned_ap_info->ssid,  ap_info_rst[i].ssid,  assigned_ap_info->s_len);
            assigned_ap_info->ssid[assigned_ap_info->s_len] = '\0';
        }
    }

__exit:
    if (NULL == assigned_ap_info)
    {
        ret = OPRT_OS_ADAPTER_AP_NOT_FOUND;
    }
    *ap_ary = assigned_ap_info;

    if (ap_info) {
        OS_Free(ap_info);
        ap_info = NULL;
    }

    LOG(LOG_LVL_INFO, "ap scan complete, %d\r\n", ret);

    return ret;
}

static WF_AP_AUTH_MODE_E __ln_authome_to_tuya_authmode(wifi_auth_mode_t ln_authmode)
{
    // WAAM_OPEN = 0,      ///< open
    // WAAM_WEP,           ///< WEP
    // WAAM_WPA_PSK,       ///< WPA—PSK
    // WAAM_WPA2_PSK,      ///< WPA2—PSK
    // WAAM_WPA_WPA2_PSK,  ///< WPA/WPA2
    // WAAM_WPA_WPA3_SAE,
    // WAAM_UNKNOWN,       //unknown
    WF_AP_AUTH_MODE_E tuya_authmode = WAAM_OPEN;
    switch (ln_authmode)
    {
        // WIFI_AUTH_OPEN                = 0,   /**<  authenticate mode : open */
        // WIFI_AUTH_WEP                 = 1,   /**<  authenticate mode : WEP */
        // WIFI_AUTH_WPA_PSK             = 2,   /**<  authenticate mode : WPA_PSK */
        // WIFI_AUTH_WPA2_PSK            = 3,   /**<  authenticate mode : WPA2_PSK */
        // WIFI_AUTH_WPA_WPA2_PSK        = 4,   /**<  authenticate mode : WPA_WPA2_PSK */
        // WIFI_AUTH_WPA2_ENTERPRISE     = 5,   /**<  authenticate mode : WPA2_ENTERPRISE */
        case WIFI_AUTH_OPEN:
            tuya_authmode = WAAM_OPEN;
            break;
        case WIFI_AUTH_WEP:
            tuya_authmode = WAAM_WEP;
            break;
        case WIFI_AUTH_WPA_PSK:
            tuya_authmode = WAAM_WPA_PSK;
            break;
        case WIFI_AUTH_WPA2_PSK:
            tuya_authmode = WAAM_WPA2_PSK;
            break;
        case WIFI_AUTH_WPA_WPA2_PSK:
        case WIFI_AUTH_WPA2_ENTERPRISE:
            tuya_authmode = WAAM_WPA_WPA2_PSK;
            break;
        //TODO:WAP3
        default:
            tuya_authmode = WAAM_UNKNOWN;

    }
    return tuya_authmode;

}
static OPERATE_RET __ln_ap_scan2(wifi_scan_cfg_t *scan_cfg, const int8_t *ssid, AP_IF_S **ap_ary, uint32_t *num)
{
    OPERATE_RET ret = OPRT_OK;
    ap_info_t *ap_info = NULL;
    AP_IF_S *assigned_ap_info = NULL;
    int ap_info_items = 20;
    ap_info_t *ap_info_rst = NULL;
    int ap_info_rst_items = 0;
    if (ap_ary == NULL){
        LOG(LOG_LVL_ERROR, "ap_ary is null\r\n");
    }
   
    tkl_semaphore_create_init(&ln_ap_scan_sem, 0, 1);
    if (!ln_ap_scan_sem) {
        ret = OPRT_OS_ADAPTER_COM_ERROR;
        goto __exit;
    }

    ap_info = OS_Malloc(ap_info_items * sizeof(ap_info_t));
    if (!ap_info) {
        ret = OPRT_OS_ADAPTER_MALLOC_FAILED;
        goto __exit;
    }

    wifi_softap_scan(scan_cfg, ap_info, ap_info_items, ln_wifi_ap_scan_cpl_cb);

    // wait scan cpl semaphore
    tkl_semaphore_wait(ln_ap_scan_sem, TKL_SEM_WAIT_FOREVER);
    tkl_semaphore_release(ln_ap_scan_sem);

    // get scan result
    wifi_softap_scan_results_get(&ap_info_rst, &ap_info_rst_items);
    LOG(LOG_LVL_INFO, "ap scan results:%d\r\n", ap_info_rst_items);

    if (!ap_info_rst) {
        ret = OPRT_OS_ADAPTER_COM_ERROR;
        goto __exit;
    }

    LOG(LOG_LVL_INFO, "%10.10s   %19.16s   %4.4s   %2.2s   %4.4s\r\n",
        "ssid", "bssid", "rssi", "ch", "auth");

    uint8_t ap_count = 0;
    for (int j = 0; j < ap_info_rst_items; j++) {
        if (0 != strlen(ap_info_rst[j].ssid)){
            ap_count++;
        }
    }

    AP_IF_S *ap_arry = NULL, *ap_itr = NULL;
    ap_arry = tkl_system_malloc(sizeof(AP_IF_S) * ap_count);
    //TODO: ap_arry = NULL?
    memset(ap_arry, 0, (sizeof(AP_IF_S) * ap_count));
    ap_itr = ap_arry;

    for (int i = 0; i < ap_info_rst_items; i++) {

        if (0 != strlen(ap_info_rst[i].ssid)){
            LOG(LOG_LVL_INFO, "%10.10s   [%02x:%02x:%02x:%02x:%02x:%02x]"
            "   %4d   %2d   %4d\r\n",
            ap_info_rst[i].ssid, ap_info_rst[i].bssid[0],
            ap_info_rst[i].bssid[1], ap_info_rst[i].bssid[2],
            ap_info_rst[i].bssid[3], ap_info_rst[i].bssid[4],
            ap_info_rst[i].bssid[5], ap_info_rst[i].rssi,
            ap_info_rst[i].channel, ap_info_rst[i].authmode);

            ap_itr->channel = ap_info_rst[i].channel;
            ap_itr->security = __ln_authome_to_tuya_authmode(ap_info_rst[i].authmode);
            ap_itr->rssi    = ap_info_rst[i].rssi;
            ap_itr->s_len   = strlen(ap_info_rst[i].ssid);

            memcpy(ap_itr->bssid, ap_info_rst[i].bssid, BSSID_LEN);
            memcpy(ap_itr->ssid,  ap_info_rst[i].ssid,  ap_itr->s_len);
            ap_itr->ssid[ap_itr->s_len] = '\0';
            ap_itr++;
        }
    }

__exit:
    //if (NULL == assigned_ap_info)
    //{
        //ret = OPRT_OS_ADAPTER_AP_NOT_FOUND;
    //}
    *ap_ary = ap_arry;
    *num = ap_count;

    if (ap_info) {
        OS_Free(ap_info);
        ap_info = NULL;
    }

    LOG(LOG_LVL_INFO, "ap scan complete,ret=%d, ap_num=%d\r\n", ret, *num);

    return ret;
}

/**
 * @brief scan current environment and obtain the ap
 *        infos in current environment
 * 
 * @param[in]       ssid        the specific ssid
 * @param[out]      ap_ary      current ap info array
 * @param[out]      num         the num of ar_ary
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 *
 * @note if ssid == NULL means scan all ap, otherwise means scan the specific ssid
 */
OPERATE_RET tkl_wifi_scan_ap(const int8_t *ssid, AP_IF_S **ap_ary, uint32_t *num)
{
    wifi_mode_t mode = wifi_current_mode_get();

    LOG(LOG_LVL_INFO, "tkl_wifi_scan_ap\r\n");

    if (mode == WIFI_MODE_STATION) {
        if (ssid == NULL) {
            return __tkl_wifi_all_ap_scan(ap_ary, num);
        } else {
            return __tkl_wifi_assign_ap_scan(ssid, ap_ary);
        }
    } else if (mode == WIFI_MODE_AP) {
        wifi_scan_cfg_t scan_cfg = {.scan_time = 100};
        if (ssid != NULL) {
            OPERATE_RET ret = OPRT_OK;
            volatile cnt = 0;
            do {
                cnt++;
                ret = __ln_ap_scan(&scan_cfg, ssid, ap_ary);
            } while((cnt < 3) && (ret != OPRT_OK));
            return ret;
        } else {
            // Not supported.
            OPERATE_RET ret = __ln_ap_scan2(&scan_cfg, ssid, ap_ary, num);
            if (ret != 0){
                return OPRT_COM_ERROR;
            }
            return OPRT_OK;
        }
    }
}

/**
 * @brief release the memory malloced in <tkl_wifi_ap_scan>
 *        if needed. tuyaos will call this function when the 
 *        ap info is no use.
 * 
 * @param[in]       ap          the ap info
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_release_ap(AP_IF_S *ap)
{
    if (NULL == ap) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }

    tkl_system_free(ap);
    ap=NULL;

    return OPRT_OK;
}

/**
 * @brief start a soft ap
 * 
 * @param[in]       cfg         the soft ap config
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_start_ap(const WF_AP_CFG_IF_S *cfg)
{
     wifi_softap_cfg_t ap_cfg = {0};
    uint8_t psk_value[40]    = {0};
    NW_MAC_S mac;
    tuya_hal_wifi_params_t *wifi_params = WIFI_PARAMS_GET();

    if (NULL == cfg) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }

    if (0 == wifi_params->ty_wifi_started)
    {
        tuya_hal_wifi_start(WWM_SOFTAP);
    }

    tkl_wifi_get_mac(WF_AP, &mac);

    ap_cfg.ext_cfg.channel = cfg->chan;
    ap_cfg.ext_cfg.authmode = (wifi_auth_mode_t)cfg->md;
    ap_cfg.ext_cfg.ssid_hidden = cfg->ssid_hidden;
    ap_cfg.ext_cfg.beacon_interval = (cfg->ms_interval == 0) ? 100 : cfg->ms_interval;

    ap_cfg.ssid  = (char *)cfg->ssid;
    ap_cfg.pwd   = (char *)cfg->passwd;
    ap_cfg.bssid = (uint8_t *)mac.mac;

    LOG(LOG_LVL_INFO, "ssid:%s; pwd:%s; channel:%d, ecn:%d, max conn:%d, hidden:%d" \
        "beacon:%d, mac:%02x:%02x:%02x:%02x:%02x:%02x; start:%d\r\n",
        ap_cfg.ssid, ap_cfg.pwd, ap_cfg.ext_cfg.channel,
        ap_cfg.ext_cfg.authmode, cfg->max_conn, ap_cfg.ext_cfg.ssid_hidden,
        ap_cfg.ext_cfg.beacon_interval,
        mac.mac[0], mac.mac[1], mac.mac[2], mac.mac[3], mac.mac[4], mac.mac[5], wifi_params->ty_wifi_started);

    wifi_stop();
    //netdev_set_state(NETIF_IDX_AP, NETDEV_DOWN);

    {
        tcpip_ip_info_t  ip_info = {0};
        server_config_t  server_config = {0};
        uint32_t dhcps_start = 0;
        uint32_t dhcps_end = 0;

        // sysparam_softap_ip_info_get(&ip_info);
        // sysparam_dhcpd_cfg_get(&server_config);

        ip_info.ip.addr      = ipaddr_addr((const char *)cfg->ip.ip);
        ip_info.gw.addr      = ipaddr_addr((const char *)cfg->ip.gw);
        ip_info.netmask.addr = ipaddr_addr((const char *)cfg->ip.mask);

        server_config.server.addr   = ip_info.ip.addr;
        server_config.port          = 67;
        server_config.lease         = 2880;
        server_config.renew         = 2880;
        server_config.client_max    = (cfg->max_conn > 3) ? 3 : cfg->max_conn;

        dhcps_start = (uint32_t)server_config.server.addr;
        dhcps_end   = (((dhcps_start >> 24) + cfg->max_conn) << 24) | (dhcps_start & 0x00FFFFFF);
        dhcps_start = (((dhcps_start >> 24) + 1) << 24) | (dhcps_start & 0x00FFFFFF);

        server_config.ip_start.addr = dhcps_start;
        server_config.ip_end.addr   = dhcps_end;

        if (LN_FALSE != dhcpd_is_running())
        {
            /* dhcpd is running, stop it first */
            dhcpd_stop();
        }

        if (DHCPD_ERR_NONE != dhcpd_curr_config_set(&server_config))
        {
            LOG(LOG_LVL_INFO, "dhcpd has been running!\r\n");
        }

        LOG(LOG_LVL_INFO, "ip info: \r\n");
        LOG(LOG_LVL_INFO, "\tip:      %s\r\n", ip4addr_ntoa(&ip_info.ip));
        LOG(LOG_LVL_INFO, "\tgw:      %s\r\n", ip4addr_ntoa(&ip_info.gw));
        LOG(LOG_LVL_INFO, "\tnetmask: %s\r\n", ip4addr_ntoa(&ip_info.netmask));

        LOG(LOG_LVL_INFO, "server config:\r\n");
        LOG(LOG_LVL_INFO, "\tip:       %s\r\n", ip4addr_ntoa(&server_config.server));
        LOG(LOG_LVL_INFO, "\tip start: %s\r\n", ip4addr_ntoa(&server_config.ip_start));
        LOG(LOG_LVL_INFO, "\tip end:   %s\r\n", ip4addr_ntoa(&server_config.ip_end));

        LOG(LOG_LVL_INFO,
                "port:%d\r\n" \
                "lease:%d\r\n" \
                "renew:%d\r\n" \
                "max client:%d\r\n",
                server_config.port,
                server_config.lease, server_config.renew, server_config.client_max);

        netdev_set_mac_addr(NETIF_IDX_AP, ap_cfg.bssid);
        netdev_set_ip_info(NETIF_IDX_AP, &ip_info);
        netdev_set_active(NETIF_IDX_AP);
    }

    ap_cfg.ext_cfg.psk_value = NULL;
    if ((ap_cfg.pwd != NULL && strlen((const char *)ap_cfg.pwd) > 0) &&
        (ap_cfg.ext_cfg.authmode != WIFI_AUTH_OPEN) &&
        (ap_cfg.ext_cfg.authmode != WIFI_AUTH_WEP)) {
        memset(psk_value, 0, sizeof(psk_value));
        if (0 == ln_psk_calc((const char *)ap_cfg.ssid, (const char *)ap_cfg.pwd, (uint8_t *)psk_value, sizeof(psk_value))) {
            ap_cfg.ext_cfg.psk_value = psk_value;
            hexdump(LOG_LVL_DEBUG, "psk value ", psk_value, sizeof(psk_value));
        }
    }

    wifi_manager_reg_event_callback(WIFI_MGR_EVENT_SOFTAP_STARTUP, &ap_startup_cb);

    if (0 != wifi_softap_start(&ap_cfg))
    {
        LOG(LOG_LVL_ERROR, "[%s:%d] wifi_softap_start() failed!", __func__, __LINE__);
        goto __exit;
    }

    wifi_softap_set_max_supp_sta_num(cfg->max_conn);

    wifi_params->ty_wifi_started = 1;
    return OPRT_OK;

__exit:
    return OPRT_OS_ADAPTER_AP_START_FAILED;
}

/**
 * @brief stop a soft ap
 * 
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_stop_ap(void)
{
    tuya_hal_wifi_params_t *wifi_params = WIFI_PARAMS_GET();

    if(wifi_params->mode != WWM_SOFTAP || wifi_params->ty_wifi_started == 0) {
        LOG(LOG_LVL_ERROR, "[%s:%d] wifi is not started\r\n", __func__, __LINE__);
        LOG(LOG_LVL_ERROR, "Error at [%s:%d]\r\n", __func__, __LINE__);
        return OPRT_OS_ADAPTER_AP_STOP_FAILED;
    }

    LOG(LOG_LVL_INFO, "[%s:%d], stop ap\r\n", __func__, __LINE__);

    return OPRT_OK;
}

/**
 * @brief set wifi interface work channel
 * 
 * @param[in]       chan        the channel to set
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_set_cur_channel(const uint8_t chan)
{
    COUNTRY_CODE_E ccode;
    tuya_hal_wifi_params_t *wifi_params = WIFI_PARAMS_GET();

    if(0 == wifi_params->ty_wifi_started){
        LOG(LOG_LVL_DEBUG, "[%s:%d] wifi is not started\r\n", __func__, __LINE__);
        tuya_hal_wifi_start(WWM_STATION);
    }

    if(OPRT_OK != tuya_hal_wifi_get_country_code(&ccode)){
        return OPRT_OS_ADAPTER_CHAN_SET_FAILED;
    }

    if(((ccode == COUNTRY_CODE_CN || ccode == COUNTRY_CODE_EU) && (chan > 13 || chan == 0))
        ||((ccode == COUNTRY_CODE_US) && (chan > 11 || chan == 0))
        ||((ccode == COUNTRY_CODE_JP) && (chan > 14 || chan == 0))) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }

    wifi_set_channel((uint8_t)chan);
    return OPRT_OK;
}

/**
 * @brief get wifi interface work channel
 * 
 * @param[out]      chan        the channel wifi works
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_get_cur_channel(uint8_t *chan)
{
    uint8_t channel = 0;
    tuya_hal_wifi_params_t *wifi_params = WIFI_PARAMS_GET();

    if(chan == NULL) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }

    if(0 == wifi_params->ty_wifi_started){
        LOG(LOG_LVL_DEBUG, "[%s:%d] wifi is not started\r\n", __func__, __LINE__);
        tuya_hal_wifi_start(WWM_STATION);
    }

    wifi_get_channel(&channel);
    *chan = channel;

    return OPRT_OK;
}

/**
 * @brief enable / disable wifi sniffer mode.
 *        if wifi sniffer mode is enabled, wifi recv from
 *        packages from the air, and user shoud send these
 *        packages to tuya-sdk with callback <cb>.
 * 
 * @param[in]       en          enable or disable
 * @param[in]       cb          notify callback
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_set_sniffer(const BOOL_T en, const SNIFFER_CALLBACK cb)
{
    tuya_hal_wifi_params_t *wifi_params = WIFI_PARAMS_GET();

    if (en && (NULL == cb)) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }

    if (0 == wifi_params->ty_wifi_started) {
        LOG(LOG_LVL_DEBUG, "[%s:%d] wifi is not started\r\n", __func__, __LINE__);
        tuya_hal_wifi_start(WWM_STATION);
    }

    if (en) {
        sniffer_cfg_t sniffer_cfg = {
            .enable = 1,
            .type = 0,
            .filter_mask = (WIFI_SNIFFER_FILTER_MASK_DATA | WIFI_SNIFFER_FILTER_MASK_MGMT)
        };

        if (wifi_current_mode_get() != WIFI_MODE_STATION)
        {
            LOG(LOG_LVL_ERROR, "[%s:%d] work mode error\r\n", __func__, __LINE__);
            return OPRT_OS_ADAPTER_SNIFFER_SET_FAILED;
        }

        wifi_params->sniffer_cb = (SNIFFER_CALLBACK)cb;

        wifi_set_allow_cpu_sleep_flag(0);
        //in sniffer mode, not allow low power mode
        wifi_sta_set_powersave(WIFI_NO_POWERSAVE);

        //Register promiscuous rx callback
        wifi_sta_set_sniffer_cfg(&sniffer_cfg, (wifi_sniffer_cb_t)tuya_hal_wifi_sniffer_handler);

        wifi_params->is_sniffer_conf = 1;

    } else {
        sniffer_cfg_t sniffer_cfg = { 0 };

        if (wifi_params->is_sniffer_conf == 1) {
            if (0 != wifi_sta_set_sniffer_cfg(&sniffer_cfg, (wifi_sniffer_cb_t)tuya_hal_wifi_sniffer_handler)) {
                LOG(LOG_LVL_INFO, "Stop sniffer mode failed!\r\n");
            }
            wifi_params->is_sniffer_conf = 0;
        }

        wifi_params->sniffer_cb = NULL;
        wifi_sta_set_powersave(wifi_params->ps_mode);
        tuya_hal_wifi_start(WWM_STATION);
    }

    return OPRT_OK;
}

/**
 * @brief get wifi ip info.when wifi works in
 *        ap+station mode, wifi has two ips.
 * 
 * @param[in]       wf          wifi function type
 * @param[out]      ip          the ip addr info
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_get_ip(const WF_IF_E wf, NW_IP_S *ip)
{
     tcpip_ip_info_t ip_info = {0};
    wifi_mode_t mode = WIFI_MODE_STATION;
    netif_idx_t net_if_idx;

    if(ip == NULL) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }

    mode = wifi_current_mode_get();
    if ((WF_STATION == wf) && mode != WIFI_MODE_STATION) {
        LOG(LOG_LVL_ERROR, "expect wf sta, but ap\r\n");
        return OPRT_OS_ADAPTER_COM_ERROR;
    } else if ((WF_AP == wf) && mode != WIFI_MODE_AP) {
        LOG(LOG_LVL_ERROR, "expect wf ap, but sta\r\n");
        return OPRT_OS_ADAPTER_COM_ERROR;
    }

    net_if_idx = (wf == WF_STATION) ? NETIF_IDX_STA: NETIF_IDX_AP;

    if (NETDEV_LINK_UP != netdev_get_link_state(netdev_get_active())) {
        LOG(LOG_LVL_ERROR, "link is down\r\n");
        return OPRT_OS_ADAPTER_COM_ERROR;
    }

    if(!netif_is_link_up(netdev_get_netif(net_if_idx))){
        LOG(LOG_LVL_ERROR, "network is not up yet!\r\n");
        return OPRT_OS_ADAPTER_NOT_SUPPORTED;
    }

    netdev_get_ip_info(net_if_idx, &ip_info);

    inet_ntoa_r(ip_info.ip, ip->ip, sizeof(ip->ip));
    inet_ntoa_r(ip_info.gw, ip->gw, sizeof(ip->gw));
    inet_ntoa_r(ip_info.netmask, ip->mask, sizeof(ip->mask));

    return OPRT_OK;
}

/**
 * @brief get wifi ip info.when wifi works in
 *        ap+station mode, wifi has two ips.
 *
 * @param[in]       wf          wifi function type
 * @param[in]       wf          wifi ip type
 * @param[out]      ip          the ip addr info
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_get_ipv6(const WF_IF_E wf, NW_IP_TYPE type, NW_IP_S *ip)
{
    // --- BEGIN: user implements ---
    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

/**
 * @brief wifi set ip
 *
 * @param[in]       wf     wifi function type
 * @param[in]       ip     the ip addr info
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_set_ip(const WF_IF_E wf, NW_IP_S *ip)
{
    // --- BEGIN: user implements ---
    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

/**
 * @brief set wifi mac info.when wifi works in
 *        ap+station mode, wifi has two macs.
 * 
 * @param[in]       wf          wifi function type
 * @param[in]       mac         the mac info
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_set_mac(const WF_IF_E wf, const NW_MAC_S *mac)
{
    wifi_mode_t mode = WIFI_MODE_STATION;
    tuya_hal_wifi_params_t *wifi_params = WIFI_PARAMS_GET();

    if(mac == NULL) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }

    if(0 == wifi_params->ty_wifi_started){
        LOG(LOG_LVL_DEBUG, "[%s:%d] start wifi first\r\n", __func__, __LINE__);
        tuya_hal_wifi_start((wf == WF_STATION) ? WWM_STATION : WWM_SOFTAP);
    }

    LOG(LOG_LVL_INFO, "set %d mac %02x %02x %02x %02x %02x %02x\r\n", wf,
            mac->mac[0], mac->mac[1], mac->mac[2], mac->mac[3], mac->mac[4], mac->mac[5]);

    wifi_set_macaddr(STATION_IF, (const uint8_t *)mac->mac);
    sysparam_sta_mac_update((const uint8_t *)mac->mac);

    // 参考bk7231n的处理:
    // 设置蓝牙mac为station的mac地址倒置，最后一个地址+1
    uint8_t m[MAC_ADDR_LEN];
    for(int i = 0; i < MAC_ADDR_LEN; i++)
        m[i] = mac->mac[MAC_ADDR_LEN - 1 - i];
    m[0] += 1;
    if (KV_ERR_NONE != ln_kv_set(KV_BLE_MAC, (void *)m, MAC_ADDR_LEN)) {
        LOG(LOG_LVL_ERROR, "set ble mac to kv error!\r\n");
    }

    LOG(LOG_LVL_INFO, "set ble mac %02x:%02x:%02x:%02x:%02x:%02x\r\n",
            m[0], m[1], m[2], m[3], m[4], m[5]);

    return OPRT_OK;
}

/**
 * @brief get wifi mac info.when wifi works in
 *        ap+station mode, wifi has two macs.
 *
 * @param[in]       wf          wifi function type
 * @param[out]      mac         the mac info
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_get_mac(const WF_IF_E wf, NW_MAC_S *mac)
{
    wifi_interface_t if_index;
    wifi_mode_t mode = WIFI_MODE_STATION;
    tuya_hal_wifi_params_t *wifi_params = WIFI_PARAMS_GET();
    uint8_t shadow_mac[6] = {0};

    if(mac == NULL) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }

    if(0 == wifi_params->ty_wifi_started){
        LOG(LOG_LVL_DEBUG, "[%s:%d] wifi is not started\r\n", __func__, __LINE__);
        tuya_hal_wifi_start((wf == WF_STATION) ? WWM_STATION : WWM_SOFTAP);
    }

//    mode = wifi_current_mode_get();
//    if ((WF_STATION == wf) && mode != WIFI_MODE_STATION) {
//        LOG(LOG_LVL_ERROR, "Error at [%s:%d], wf %d, mode %d\r\n",
//                __func__, __LINE__, wf, mode);
//        return OPRT_OS_ADAPTER_COM_ERROR;
//    } else if ((WF_AP == wf) && mode != WIFI_MODE_AP) {
//        LOG(LOG_LVL_ERROR, "Error at [%s:%d], wf %d, mode %d\r\n",
//                __func__, __LINE__, wf, mode);
//       return OPRT_OS_ADAPTER_COM_ERROR;
//    }

    //if_index = (wf == WF_STATION) ? STATION_IF : SOFT_AP_IF;

    if_index = STATION_IF;
    wifi_get_macaddr(if_index, shadow_mac);

    if (wf == WF_AP) {

        // 参考bk7231n获取mac接口描述：
        // if support AP+STA, mac addr should be equal with each other in
        // byte0-4 & byte5[7:2], byte5[1:0] can be different
        // ie: mac[5]= 0xf7,  so mac[5] can be 0xf4, f5, f6.
        uint8_t mask = 0x01, low = 0;

        // 这里，取mac[5]的最低位取反区分地址,二者差值为1
        low = mask & shadow_mac[5];
        low ^= mask;
        shadow_mac[5] &= ~mask;
        shadow_mac[5] |= low;
    }

    memcpy(mac->mac, shadow_mac, 6);

    LOG(LOG_LVL_INFO, "[%s:%d] if: %d, mac: %02x:%02x:%02x:%02x:%02x:%02x\r\n",
        __func__, __LINE__, wf,
        mac->mac[0], mac->mac[1], mac->mac[2], mac->mac[3], mac->mac[4], mac->mac[5]);

    uint8_t ble_mac[MAC_ADDR_LEN];
    size_t v_len = 0;
    ln_kv_get(KV_BLE_MAC, (void *)ble_mac, MAC_ADDR_LEN, &v_len);
    LOG(LOG_LVL_INFO, "ble_mac: %02x:%02x:%02x:%02x:%02x:%02x\r\n",
        ble_mac[0], ble_mac[1], ble_mac[2], ble_mac[3], ble_mac[4], ble_mac[5]);

    return OPRT_OK;
}


/**
 * @brief set wifi work mode
 * 
 * @param[in]       mode        wifi work mode
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_set_work_mode(const WF_WK_MD_E mode)
{
    wifi_mode_t  ln_wifi_mode, curr_mode;
    tuya_hal_wifi_params_t *wifi_params = WIFI_PARAMS_GET();
    wifi_params->mode = mode;

    LOG(LOG_LVL_INFO, "set work mode %d, is open %d, current ln mode: %d\r\n",
            mode, wifi_params->ty_wifi_started, wifi_current_mode_get());

    switch(mode)
    {
        case WWM_STATION:
            ln_wifi_mode=WIFI_MODE_STATION;
            break;
        case WWM_SOFTAP:
            ln_wifi_mode=WIFI_MODE_AP;
            break;
        case WWM_POWERDOWN:
            LOG(LOG_LVL_INFO, "WWM_POWERDOWN ... ...\r\n");
            return OPRT_OK;
        case WWM_STATIONAP:
            // ln_wifi_mode = WIFI_MODE_AP_STATION;
            // break;
        case WWM_SNIFFER:
        default:
            ln_wifi_mode = WIFI_MODE_STATION;
            break;
    }

    if (wifi_params->ty_wifi_started == 0) {
        LOG(LOG_LVL_INFO, "wifi not start, turn on first\r\n");
        tuya_hal_wifi_start(mode);
    }

    curr_mode = wifi_current_mode_get();
    LOG(LOG_LVL_INFO, "current work mode %d\r\n", curr_mode);
    if (curr_mode == ln_wifi_mode) {
        LOG(LOG_LVL_INFO, "No need to switch mode, mode:%d\r\n", curr_mode);
        goto __ok;
    }

    wifi_stop();
    if (curr_mode == WIFI_MODE_STATION) {
        netdev_set_state(NETIF_IDX_STA, NETDEV_DOWN);
    } else {
        netdev_set_state(NETIF_IDX_AP, NETDEV_DOWN);
    }

    if (ln_wifi_mode == WIFI_MODE_STATION)
    {
        uint8_t mac_addr[MAC_ADDRESS_LEN];
        sysparam_sta_mac_get(mac_addr);
        netdev_set_mac_addr(NETIF_IDX_STA, mac_addr);
        netdev_set_active(NETIF_IDX_STA);
        wifi_sta_start(mac_addr, wifi_params->ps_mode);
    }
    else
    {
        uint8_t mac_addr[MAC_ADDRESS_LEN];
        sysparam_softap_mac_get(mac_addr);
        wifi_softap_cfg_t ap_cfg = {
            .ssid            = "temp",
            .pwd             = "",
            .bssid           = mac_addr,
            .ext_cfg = {
                .channel         = 6,
                .authmode        = WIFI_AUTH_WPA_WPA2_PSK,
                .ssid_hidden     = 1,
                .beacon_interval = 100,
                .psk_value = NULL,
            }
        };

        ap_cfg.ext_cfg.psk_value = NULL;
        netdev_set_active(NETIF_IDX_AP);
        wifi_softap_start(&ap_cfg);
    }

__ok:
    return OPRT_OK;
}

/**
 * @brief get wifi work mode
 * 
 * @param[out]      mode        wifi work mode
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_get_work_mode(WF_WK_MD_E *mode)
{
    tuya_hal_wifi_params_t *wifi_params = WIFI_PARAMS_GET();

    *mode = wifi_params->mode;

    return OPRT_OK;
}

/**
 * @brief : get ap info for fast connect
 * @param[out]      fast_ap_info
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_get_connected_ap_info(FAST_WF_CONNECTED_AP_INFO_T **fast_ap_info)
{
    FAST_WF_CONNECTED_AP_INFO_T *ap_infor_v2_buf = NULL;
    unsigned int len = sizeof(tuya_hal_wifi_psk_info_t);

    int ret = 0;

    if(NULL == fast_ap_info) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }

    ap_infor_v2_buf = (FAST_WF_CONNECTED_AP_INFO_T *)tkl_system_malloc(sizeof(FAST_WF_CONNECTED_AP_INFO_T) - 1 + len);
    if(NULL == ap_infor_v2_buf) {
        return OPRT_OS_ADAPTER_MALLOC_FAILED;
    }
    memset(ap_infor_v2_buf, 0, sizeof(FAST_WF_CONNECTED_AP_INFO_T) - 1 + len);
    ap_infor_v2_buf->len = len;

    ret = tuya_hal_wifi_psk_get((tuya_hal_wifi_psk_info_t *)(ap_infor_v2_buf->data));
    if (ret != 0) {
        tkl_system_free(ap_infor_v2_buf);
        *fast_ap_info = NULL;
        return OPRT_OS_ADAPTER_APINFO_GET_FAILED;
    }

    *fast_ap_info = (void *)ap_infor_v2_buf;

    return OPRT_OK;
}

/**
 * @brief get wifi bssid
 * 
 * @param[out]      mac         uplink mac
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_get_bssid(uint8_t *mac)
{
    const char *ssid = NULL;
    const uint8_t *bssid = NULL;
    tuya_hal_wifi_params_t *wifi_params = WIFI_PARAMS_GET();

    if (NULL == mac) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }

    if (wifi_params->mode != WWM_STATION || wifi_params->ty_wifi_started == 0) {
        LOG(LOG_LVL_ERROR, "[%s:%d] wifi is not started\r\n", __func__, __LINE__);
        return OPRT_COM_ERROR;
    }

    wifi_get_sta_conn_info(&ssid, &bssid);
    if (bssid != NULL) {
        LOG(LOG_LVL_DEBUG, "conn ap bssid: %02x:%02x:%02x:%02x:%02x:%02x\r\n",
                bssid[0], bssid[1], bssid[2], bssid[3], bssid[4], bssid[5]);
        memcpy(mac, bssid, MAC_ADDRESS_LEN);
    } else {
        return OPRT_COM_ERROR;
    }
    return OPRT_OK;
}

/**
 * @brief set wifi country code
 * 
 * @param[in]       ccode  country code
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_set_country_code(const COUNTRY_CODE_E ccode)
{
    tuya_hal_wifi_params_t *wifi_params = WIFI_PARAMS_GET();
    wifi_country_code_t ctry_code;

    if (0 == wifi_params->ty_wifi_started) {
        LOG(LOG_LVL_DEBUG, "[%s:%d] wifi is not started\r\n", __func__, __LINE__);
        tuya_hal_wifi_start(WWM_STATION);
    }

    wifi_params->ccode = ccode;

    if (ccode == COUNTRY_CODE_EU) {
        ctry_code = CTRY_CODE_CN;
    } else {
        ctry_code = (wifi_country_code_t)ccode;
    }

    if (0 != wifi_set_country_code(ctry_code)) {
        return OPRT_OS_ADAPTER_CCODE_SET_FAILE;
    }

    return OPRT_OK;
}

/**
 * @brief do wifi calibration
 *
 * @note called when test wifi
 *
 * @return true on success. faile on failure
 */
OPERATE_RET tkl_wifi_set_rf_calibrated(void)
{
    uint8_t val = 0;
    return true;
    if (NVDS_ERR_OK == ln_nvds_get_ate_result(&val)) {
        if (val == NV9_ATE_RESULT_OK) {
            return true;
        } else if (val == NV9_ATE_RESULT_FAILED){
            return false;
        } else {
            LOG(LOG_LVL_ERROR, "[%s:%d] ATE test not done!\r\n", __func__, __LINE__);
            return false;
        }
    } else {
        LOG(LOG_LVL_ERROR, "[%s:%d] get ATE result failed!\r\n", __func__, __LINE__);
        return false;
    }
}

static void local_lp_mode_set(const BOOL_T enable)
{
    tuya_hal_wifi_params_t *wifi_params = WIFI_PARAMS_GET();

#if defined(ENABLE_BLUETOOTH) && (ENABLE_BLUETOOTH==1)
    //在sdk init ble_stack 之前 platform不能init ble_stack。
    //（如果platform在sdk init ble_stack 之前先init ble_stack，会导致tuya的gatt service丢失）
    static bool bt_host_stack_init = 0;
    if(bt_host_stack_init == 0)
        bt_host_stack_init = ble_hs_is_enabled();
#endif

    if (enable == 1) {
#if defined(ENABLE_BLUETOOTH) && (ENABLE_BLUETOOTH == 1)
        // stop ble adv
        // suspend ble main task
        {
            extern OPERATE_RET tkl_ble_gap_adv_stop(void);
            extern OPERATE_RET tkl_ble_stack_deinit(uint8_t role);

            if(bt_host_stack_init == true) {
                LOG(LOG_LVL_INFO, "%s %d, disable ble stack\r\n", __func__, __LINE__);
                tkl_ble_stack_deinit(1);
            }
        }

        // disable ble clock
        {
            LOG(LOG_LVL_INFO, "%s %d, disable ble clock gate\r\n", __func__, __LINE__);
            soc_module_clk_gate_disable(CLK_G_BLE);
        }
#endif

        // set cpu_wifi_mode_dr as 1
        {
            #undef     RF_P0_BASE
            #define    RF_P0_BASE                 0x40012000
            #undef     CPU_WIFI_MODE_DR_BIT
            #define    CPU_WIFI_MODE_DR_BIT       (1 << 31)
            uint32_t old = 0;
            volatile uint32_t *rf_addr = (uint32_t *)(RF_P0_BASE + 4 * 0x7b);
            old = *rf_addr;
            *rf_addr = old | (CPU_WIFI_MODE_DR_BIT);
        }

        if (wifi_current_mode_get() == WIFI_MODE_STATION) {
            wifi_sta_set_powersave(TY_ADA_WIFI_PS_MODE);
            wifi_params->ps_mode = TY_ADA_WIFI_PS_MODE;
        }

        LOG(LOG_LVL_INFO, "--> enter LIGHT_SLEEP mode\r\n");
        ln_pm_sleep_mode_set(LIGHT_SLEEP);
    } else {
        ln_pm_sleep_mode_set(ACTIVE);
        LOG(LOG_LVL_INFO, "<-- enter ACTIVE mode\r\n");

        // set cpu_wifi_mode_dr as 0
        {
            #define    RF_P0_BASE                 0x40012000
            #define    CPU_WIFI_MODE_DR_BIT       (1 << 31)
            uint32_t old = 0;
            volatile uint32_t *rf_addr = (uint32_t *)(RF_P0_BASE + 4 * 0x7b);
            old = *rf_addr;
            *rf_addr = old & (~(CPU_WIFI_MODE_DR_BIT));
        }

#if defined(ENABLE_BLUETOOTH) && (ENABLE_BLUETOOTH == 1)
        {
            LOG(LOG_LVL_INFO, "%s %d, enable ble clock gate\r\n", __func__, __LINE__);
            soc_module_clk_gate_enable(CLK_G_BLE);
        }
#endif

        wifi_sta_set_powersave(TY_ADA_WIFI_DEFAULT_PS_MODE);
        wifi_params->ps_mode = TY_ADA_WIFI_DEFAULT_PS_MODE;

#if defined(ENABLE_BLUETOOTH) && (ENABLE_BLUETOOTH == 1)
        extern OPERATE_RET tkl_ble_gap_adv_start(TKL_BLE_GAP_ADV_PARAMS_T const *p_adv_params);
        extern OPERATE_RET tkl_ble_stack_init(uint8_t role);

        if(bt_host_stack_init == true){
            LOG(LOG_LVL_INFO, "ble stack init\r\n");
            tkl_ble_stack_init(1);
        }
            
#endif
    }

    LOG(LOG_LVL_TRACE, "[%s:%d] en:%d\r\n", __func__, __LINE__, enable);
}

/**
 * @brief set wifi lowpower mode
 * 
 * @param[in]       enable      enbale lowpower mode
 * @param[in]       dtim     the wifi dtim
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_set_lp_mode(const BOOL_T enable, const uint8_t dtim)
{
    tuya_hal_wifi_params_t *wifi_params = WIFI_PARAMS_GET();
    LOG(LOG_LVL_INFO, "[tkl_wifi_set_lp_mode] ================ en = %d, dtim = %d\r\n", enable, dtim);
    LOG(LOG_LVL_INFO, "%s %d, en %d, dtim %d\r\n", __func__, __LINE__, enable, dtim);
    // low power mode only in WWM_STATION
    if(wifi_params->mode != WWM_STATION || wifi_params->ty_wifi_started == 0){
        LOG(LOG_LVL_ERROR, "mode: %d, started: %d\r\n", wifi_params->mode, wifi_params->ty_wifi_started);
        return OPRT_OS_ADAPTER_COM_ERROR;
    }

    if(enable && ((dtim == 0) || (dtim > 10))) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }

    local_lp_mode_set(enable);

    return OPRT_OK;
}

/**
 * @brief : fast connect
 * @param[in]      fast_ap_info
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_station_fast_connect(const FAST_WF_CONNECTED_AP_INFO_T *fast_ap_info)
{
    tuya_hal_wifi_params_t *wifi_params = WIFI_PARAMS_GET();
    tuya_hal_wifi_psk_info_t *ap_psk_info = NULL;
    LOG(LOG_LVL_INFO, "[tkl_wifi_station_fast_connect] ================ \r\n");
    if(NULL == fast_ap_info) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }

    ap_psk_info = (tuya_hal_wifi_psk_info_t *)(fast_ap_info->data);

    if(NULL == ap_psk_info) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }

    LOG(LOG_LVL_INFO, "[%s:%d] ssid: %s pwd: %s pwd len: %d, channel: %d\r\n",
            __func__, __LINE__,
            ap_psk_info->ssid,
            ap_psk_info->pwd,
            ap_psk_info->pwd_len,
            ap_psk_info->channel);

//    LOG(LOG_LVL_INFO, "psk:\r\n");
//    for (int i = 0; i < TUYA_PSK_VAL_LEN; i++) {
//        LOG(LOG_LVL_INFO, " %x", ap_psk_info->psk[i]);
//    }
//    LOG(LOG_LVL_INFO, "\r\npsk dump end\r\n");


    if(0 == wifi_params->ty_wifi_started){
        LOG(LOG_LVL_DEBUG, "[%s:%d] wifi is not started\r\n", __func__, __LINE__);
        tuya_hal_wifi_start(WWM_STATION);
    }

    {
        uint8_t mac_addr[MAC_ADDRESS_LEN] = {0};
        wifi_sta_connect_t conn = {0};
        wifi_scan_cfg_t scan_cfg = {0};

        // wifi_sta_disconnect();
        wifi_stop();
        //netdev_set_state(NETIF_IDX_STA, NETDEV_DOWN);

        tkl_wifi_get_mac(WF_STATION, mac_addr);

        netdev_set_mac_addr(NETIF_IDX_STA, mac_addr);
        netdev_set_active(NETIF_IDX_STA);
        LOG(LOG_LVL_INFO, "ps_mode = %d\r\n", wifi_params->ps_mode);
        wifi_sta_start(mac_addr, wifi_params->ps_mode);

        conn.ssid  = (char *)ap_psk_info->ssid;
        conn.pwd   = (char *)ap_psk_info->pwd;
        conn.bssid = NULL;
        conn.psk_value = NULL;
        if (ap_psk_info->pwd_len != 0)
        {
            conn.psk_value = ap_psk_info->psk;
        }

        if (SYSPARAM_ERR_NONE != sysparam_sta_scan_cfg_get(&scan_cfg))
        {
            goto __exit;
        }

        // specify router channel
        scan_cfg.channel = ap_psk_info->channel;

        //fast connect, not allow low power mode
        wifi_set_allow_cpu_sleep_flag(0);
        if (wifi_sta_connect(&conn, &scan_cfg) != 0)
        {
            if (wifi_params->tkl_wifi_event_callback != NULL) {
                wifi_params->tkl_wifi_event_callback(WFE_CONNECT_FAILED, NULL);
            }
            LOG(LOG_LVL_ERROR, "Join failed! ssid:%s, pwd:%s\r\n",
                    conn.ssid, conn.pwd);
            goto __exit;
        }

        wifi_params->ty_wifi_started = 1;
    }

    return OPRT_OK;
__exit:
    LOG(LOG_LVL_ERROR, "[%s:%d] conn v2 failed!\r\n", __func__, __LINE__);
    return OPRT_OS_ADAPTER_NOT_SUPPORTED;
}

/**
 * @brief connect wifi with ssid and passwd
 * 
 * @param[in]       ssid
 * @param[in]       passwd
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_station_connect(const int8_t *ssid, const int8_t *passwd)
{
    uint8_t mac_addr[MAC_ADDRESS_LEN] = {0};
    wifi_sta_connect_t conn           = {0};
    wifi_scan_cfg_t scan_cfg          = {0};
    tuya_hal_wifi_params_t *wifi_params = WIFI_PARAMS_GET();
    tuya_hal_wifi_psk_info_t psk_info = {0};
    uint8_t need_cal_psk = 0;
    LOG(LOG_LVL_INFO, "[tkl_wifi_station_connect] ================ \r\n");
    LOG(LOG_LVL_INFO, "[%s:%d] ssid:%s pwd:%s ps:%d\r\n",
            __func__, __LINE__, ssid, passwd, wifi_params->ps_mode);

    if(NULL == ssid) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }

    if (wifi_params->mode != WWM_STATION) {
        return OPRT_OS_ADAPTER_COM_ERROR;
    }

    if (wifi_params->ty_wifi_started == 0)
    {
        LOG(LOG_LVL_ERROR, "[%s:%d] wifi is not started!\r\n", __func__, __LINE__);
        tuya_hal_wifi_start(WWM_STATION);
    }
    else
    {
        //connect to ap, not allow low power mode
        wifi_set_allow_cpu_sleep_flag(0);
        // wifi_sta_disconnect();
        wifi_stop();

        //netdev_set_state(NETIF_IDX_STA, NETDEV_DOWN);

        tkl_wifi_get_mac(WF_STATION, mac_addr);
        //sysparam_sta_mac_get(mac_addr);

        netdev_set_mac_addr(NETIF_IDX_STA, mac_addr);
        netdev_set_active(NETIF_IDX_STA);
        wifi_sta_start(mac_addr, wifi_params->ps_mode);
    }

    conn.ssid  = (char *)ssid;
    conn.pwd   = (char *)((passwd != NULL) ? passwd : "");
    conn.bssid = NULL;
    conn.psk_value = NULL;

    if (SYSPARAM_ERR_NONE != sysparam_sta_scan_cfg_get(&scan_cfg))
    {
        goto __exit;
    }

    // scan stay 120ms per channel
    // scan_cfg.scan_time = 120;

    /**
     * Need to update psk regardless of whether there is a password.
     * Because the passwordless hotspot natively supports fast connection!
    */
    do {
        if (passwd == NULL) {
            break;
        }

        if (tuya_hal_wifi_psk_get(&psk_info) != 0) {
            // Failed get psk saved in kv. Recalculate psk
            LOG(LOG_LVL_TRACE, "[%d] Need to calculate psk!\r\n", __LINE__);
            need_cal_psk = 1;
        } else {
            LOG(LOG_LVL_TRACE, "flash info: ssid:%s-%s, pwd:%s-%s,plen:%d \r\n",
                    psk_info.ssid, ssid, psk_info.pwd, passwd, psk_info.pwd_len);
            if ((strlen(ssid) != strlen(psk_info.ssid)) &&
                (strncmp(psk_info.ssid, (const char *)ssid, strlen((const char *)ssid)) == 0) &&
                (psk_info.pwd_len != strlen(passwd)) &&
                (memcmp(psk_info.pwd, passwd, psk_info.pwd_len) == 0)) {
                // No need to calculate psk if the information is consistent
                conn.psk_value = psk_info.psk;
                LOG(LOG_LVL_INFO, "[%d] Find psk!\r\n", __LINE__);
                break;
            } else {
                // Recalculate psk
                need_cal_psk = 1;
                LOG(LOG_LVL_INFO, "[%d] Need to calculate psk!\r\n", __LINE__);
            }
        }

        if (need_cal_psk) {
            psk_info.pwd_len = strlen((const char *)passwd);
            strncpy(psk_info.pwd, passwd, sizeof(psk_info.pwd));
            strncpy((char *)psk_info.ssid, (const char *)ssid, sizeof(psk_info.ssid));

            LOG(LOG_LVL_TRACE, "[%d] calculate psk!\r\n", __LINE__);
            if (0 != ln_psk_calc(conn.ssid, conn.pwd, psk_info.psk, sizeof(psk_info.psk))) {
                break;
            }

            conn.psk_value = psk_info.psk;

            if (0 != tuya_hal_wifi_psk_update((const tuya_hal_wifi_psk_info_t *)&psk_info))
            {
                LOG(LOG_LVL_ERROR, "update psk info failed!\r\n");
                break;
            }
        }
    } while(0);
    LOG(LOG_LVL_INFO, "calculate psk pass, will conn!\r\n");


    if (wifi_sta_connect(&conn, &scan_cfg) != 0)
    {
        if (wifi_params->tkl_wifi_event_callback != NULL) {
            wifi_params->tkl_wifi_event_callback(WFE_CONNECT_FAILED, NULL);
        }

        LOG(LOG_LVL_ERROR, "Join failed! ssid:%s, pwd:%s\r\n",
                conn.ssid, conn.pwd);
        goto __exit;
    } else {
        LOG(LOG_LVL_INFO, "[%s:%d] wifi sta connecting <%s><%s>...\r\n",
                 __func__, __LINE__, ssid, passwd);
    }

    wifi_params->ty_wifi_started = 1;

    /**
     * Need to wait connect success, then exit this function! TODO
    */

    return OPRT_OK;

__exit:
    return OPRT_OS_ADAPTER_CONN_FAILED;
}

/**
 * @brief disconnect wifi from connect ap
 * 
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_station_disconnect(void)
{
    if (wifi_sta_disconnect() != 0)
    {
        LOG(LOG_LVL_ERROR, "sta disconn failed\r\n");
        return OPRT_OS_ADAPTER_DISCONN_FAILED;
    }

    //LOG(LOG_LVL_INFO, "sta disconnected\r\n");
    return OPRT_OK;
}

/**
 * @brief get wifi connect rssi
 * 
 * @param[out]      rssi        the return rssi
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_station_get_conn_ap_rssi(int8_t *rssi)
{
    int8_t sta_rssi = 0;
    wifi_sta_status_t status;
    tuya_hal_wifi_params_t *wifi_params = WIFI_PARAMS_GET();

    if (NULL == rssi || wifi_params->mode != WWM_STATION) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }

    if (wifi_params->ty_wifi_started == 0) {
        LOG(LOG_LVL_DEBUG, "[%s:%d] wifi is not started\r\n", __func__, __LINE__);
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }

    wifi_sta_get_rssi(&sta_rssi);
    wifi_get_sta_status(&status);

    if (status != WIFI_STA_STATUS_CONNECTED) {
        //sta_rssi = (int8_t)(-128);
        return OPRT_COM_ERROR;
    }
    *rssi = (int8_t)sta_rssi;

    return OPRT_OK;
}

/**
 * @brief get wifi station work status
 * 
 * @param[out]      stat        the wifi station work status
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_station_get_status(WF_STATION_STAT_E *stat)
{
    wifi_sta_status_t link_status = WIFI_STA_STATUS_STARTUP;
    tuya_hal_wifi_params_t *wifi_params = WIFI_PARAMS_GET();

    if(NULL == stat || wifi_params->mode != WWM_STATION) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }

    if(wifi_params->ty_wifi_started == 0)
    {
        LOG(LOG_LVL_DEBUG, "[%s:%d] wifi is not started\r\n", __func__, __LINE__);
        tuya_hal_wifi_start(WWM_STATION);
    }

    wifi_get_sta_status(&link_status);
    switch (link_status)
    {
        case WIFI_STA_STATUS_CONNECTING:
            *stat = WSS_CONNECTING;
            break;
        case WIFI_STA_STATUS_CONNECTED:
            *stat = WSS_CONN_SUCCESS;

            if (wifi_params->ty_wifi_status == WSS_GOT_IP) {
                *stat = WSS_GOT_IP;
            }
            break;
        case WIFI_STA_STATUS_DISCONNECTING:
        case WIFI_STA_STATUS_DISCONNECTED:
        case WIFI_STA_STATUS_STARTUP:
        case WIFI_STA_STATUS_SCANING:
        default:
            *stat = WSS_IDLE;
            break;
    }

//    LOG(LOG_LVL_INFO, "lowlevel:  link_status: %d, wifi status: %d\r\n",
//            link_status, *stat);
//
//    netif_idx_t ifx = netdev_get_active();
//    netdev_link_state_t s = netdev_get_link_state(ifx);
//    char *ss = (s == NETDEV_LINK_UP? "if up": "if down");
//    LOG(LOG_LVL_INFO, "lowlevel:  if: %d, status: %s\r\n", ifx, ss);

    return OPRT_OK;
}

/**
 * @brief send wifi management
 * 
 * @param[in]       buf         pointer to buffer
 * @param[in]       len         length of buffer
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_send_mgnt(const uint8_t *buf, const uint32_t len)
{
    int ret = 0;
    tuya_hal_wifi_params_t *wifi_params = WIFI_PARAMS_GET();

    if ((NULL == buf) || (len == 0) || wifi_params->ty_wifi_started == 0) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }

    ret = wifi_send_80211_mgmt_raw_frame((unsigned char *)buf, len + 4); // FCS_LEN: 4
    // LOG(LOG_LVL_ERROR, "[%s] wifi mode:%d, len:%d, ret:%d\r\n", __func__, wifi_params->mode, len, ret);
    // hexdump(LOG_LVL_ERROR, "wifi send mgnt", buf, len);

    return OPRT_OK;
}

/**
 * @brief register receive wifi management callback
 * 
 * @param[in]       enable
 * @param[in]       recv_cb     receive callback
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_register_recv_mgnt_callback(const BOOL_T enable, const WIFI_REV_MGNT_CB recv_cb)
{
    tuya_hal_wifi_params_t *wifi_params = WIFI_PARAMS_GET();

    if(enable && (NULL == recv_cb)) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }

    LOG(LOG_LVL_INFO, "[%s] mode:%d, en:%d, cb: %x\r\n", __func__, wifi_current_mode_get(), enable, recv_cb);

    if (enable) {
        sniffer_cfg_t sniffer_cfg = {
            .enable = 1,
            .type = 1,
            .filter_mask = WIFI_SNIFFER_FILTER_MASK_MGMT
        };

        if(wifi_params->ty_wifi_started == 0) {
            LOG(LOG_LVL_DEBUG, "[%s:%d] wifi is not started\r\n", __func__, __LINE__);
            tuya_hal_wifi_start(WWM_STATION);
        } else if (wifi_current_mode_get() != WIFI_MODE_STATION) {
            LOG(LOG_LVL_ERROR, "[%s:%d] work mode error\r\n", __func__, __LINE__);
            return OPRT_OS_ADAPTER_SNIFFER_SET_FAILED;
        }

        if((wifi_params->mode == WWM_POWERDOWN) || (wifi_params->mode == WWM_SNIFFER)) {
            return OPRT_OS_ADAPTER_COM_ERROR;
        }

        wifi_sta_set_powersave(WIFI_NO_POWERSAVE);

        //Register promiscuous rx callback
        wifi_sta_set_sniffer_cfg(&sniffer_cfg, (wifi_sniffer_cb_t)tuya_hal_wifi_sniffer_handler);
        wifi_params->mgnt_recv_cb = recv_cb;
        ln_wifi_mgnt_cb_set((wifi_mgnt_cb_t)ty_wifi_recv_mgnt_cb);
    } else {
        sniffer_cfg_t sniffer_cfg = { 0 };

        if (0 != wifi_sta_set_sniffer_cfg(&sniffer_cfg, (wifi_sniffer_cb_t)tuya_hal_wifi_sniffer_handler))
        {
            LOG(LOG_LVL_INFO, "Stop sniffer mode failed!\r\n");
        }

        wifi_params->mgnt_recv_cb = NULL;
        ln_wifi_mgnt_cb_set(NULL);

        wifi_sta_set_powersave(wifi_params->ps_mode);
    }

    return OPRT_OK;
}

/**
 * @brief wifi ioctl
 *
 * @param[in]       cmd     refer to WF_IOCTL_CMD_E
 * @param[in]       args    args associated with the command
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_ioctl(WF_IOCTL_CMD_E cmd, void *args)
{
    return OPRT_NOT_SUPPORTED;
}

