/**
 * @file tkl_rtc.c
 * @brief this file was auto-generated by tuyaos v&v tools, developer can add implements between BEGIN and END
 * 
 * @warning: changes between user 'BEGIN' and 'END' will be keeped when run tuyaos v&v tools
 *           changes in other place will be overwrited and lost
 *
 * @copyright Copyright 2020-2021 Tuya Inc. All Rights Reserved.
 * 
 */

// --- BEGIN: user defines and implements ---
#include "tkl_rtc.h"
#include "tuya_error_code.h"
#include "tkl_thread.h"
#include "osal/osal.h"
#include "hal/hal_rtc.h"
#include "hal/hal_misc.h"
#include "utils/debug/log.h"
// --- END: user defines and implements ---

#define RTC_TICK_TIME   1000 //unit: ms

TKL_THREAD_HANDLE rtc_cal_thread_handle = NULL;

static uint32_t ln_rtc_base = RTC_BASE;
static uint16_t rco32k_period = 0;
volatile static uint64_t g_current_time_ms = 0; //unit: ms
static uint32_t rtc_ticks_ms = 0; //unit: ms
static uint32_t rtc_match_val = 0;
static volatile uint8_t  rtc_cal_done_flag   = 0;

void platform_rtc_cal(void)
{
    if (0 == rtc_cal_done_flag) {
        hal_misc_awo_set_o_cpu_sleep_counter_bp(0);
        tkl_system_delay(1);
        rtc_match_val = ((RTC_TICK_TIME * 1000000.0f) / hal_misc_awo_get_i_rco32k_period_ns() + 0.5f) + 1;
        rtc_cal_done_flag = 1;
    }
#if 0
    tkl_system_delay(2000);
    for (;;) {
        if (0 == rtc_cal_done_flag) {
            hal_misc_awo_set_o_cpu_sleep_counter_bp(0);
            tkl_system_delay(1);
            rtc_match_val = ((RTC_TICK_TIME * 1000000.0f) / hal_misc_awo_get_i_rco32k_period_ns() + 0.5f) + 1;
            rtc_cal_done_flag = 1;
        }
        tkl_system_delay(1000);
    }
#endif
}

static uint32_t __get_rtc_ms(void)
{
    return (rtc_ticks_ms + (hal_rtc_get_cnt(ln_rtc_base) * rtc_match_val) / 1000000);
}

/**
 * @brief rtc init
 *
 * @param[in] none
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_rtc_init(void)
{
    hal_misc_awo_set_o_cpu_sleep_counter_bp(0);
    OS_MsDelay(1);
    rco32k_period = hal_misc_awo_get_i_rco32k_period_ns();

    rtc_init_t_def rtc_init;
    rtc_init.rtc_warp_en = RTC_WRAP_EN;
    hal_rtc_init(ln_rtc_base, &rtc_init);

    hal_rtc_set_cnt_match(ln_rtc_base, ((RTC_TICK_TIME * 1000000.0f) / rco32k_period) + 0.5f  + 1);
    hal_rtc_set_cnt_load(ln_rtc_base, 0);
    hal_rtc_it_cfg(ln_rtc_base, RTC_IT_FLAG_ACTIVE, HAL_ENABLE);

    NVIC_SetPriority(RTC_IRQn, 4);
    NVIC_EnableIRQ(RTC_IRQn);
    hal_rtc_en(ln_rtc_base, HAL_ENABLE);

    rtc_ticks_ms = 0;
    g_current_time_ms = 0;
    rtc_cal_done_flag = 0;

//    tkl_thread_create(&rtc_cal_thread_handle,
//                        "rtc cal",
//                        576,
//                        0,
//                        __rtc_cal_match_task,
//                        0);

    return OPRT_OK;
}

/**
 * @brief rtc deinit
 * @param[in] none
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_rtc_deinit(void)
{
    g_current_time_ms = 0;
    hal_rtc_en(ln_rtc_base, HAL_DISABLE);
    hal_rtc_deinit();
    tkl_thread_release(rtc_cal_thread_handle);

    return OPRT_OK;
}

/**
 * @brief rtc time set
 *
 * @param[in] time_sec: rtc time seconds
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_rtc_time_set(TIME_T time_sec)
{
    g_current_time_ms = (uint64_t)time_sec * 1000 - __get_rtc_ms();
    return OPRT_OK;
}

/**
 * @brief rtc time get
 *
 * @param[in] time_sec:rtc time seconds
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_rtc_time_get(TIME_T *time_sec)
{
    *time_sec = (__get_rtc_ms() + g_current_time_ms) / 1000;
    return OPRT_OK;
}

void RTC_IRQHandler()
{
    if(hal_rtc_get_it_flag(ln_rtc_base, RTC_IT_FLAG_ACTIVE) == 1)
    {
        rtc_ticks_ms += RTC_TICK_TIME;
        hal_rtc_clr_it_flag(ln_rtc_base, RTC_IT_FLAG_ACTIVE);
        if(rtc_cal_done_flag == 1){
            //hal_rtc_set_cnt_match(RTC_BASE, g_rtc_match_val);
            *(volatile uint32_t*)0x40101004 = rtc_match_val;
            rtc_cal_done_flag = 0;
        }
    }
}

