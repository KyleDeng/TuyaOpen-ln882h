/**
 * @file tkl_ota.c
 * @brief this file was auto-generated by tuyaos v&v tools, developer can add implements between BEGIN and END
 * 
 * @warning: changes between user 'BEGIN' and 'END' will be keeped when run tuyaos v&v tools
 *           changes in other place will be overwrited and lost
 *
 * @copyright Copyright 2020-2021 Tuya Inc. All Rights Reserved.
 * 
 */
// --- BEGIN: user defines and implements ---
#include "tkl_ota.h"
#include "tuya_error_code.h"
#include "ota_port.h"
#include "ota_image.h"
#include "ota_types.h"

#include "osal/osal.h"

#include "utils/debug/log.h"
#include "flash_partition_table.h"

#include "tuya_ota_header.h"
#include "tkl_system.h"
#include "tkl_flash.h"
// --- END: user defines and implements ---

#define SIZE_4K             (0x1000)
static struct ota_header _ota_hdr = {0};

static int __ota_download_precheck(uint32_t app_offset, struct ota_header * ota_hdr)
{
    LOG(LOG_LVL_INFO, "[%s:%d]: header len: %x\r\n", __func__, __LINE__, ota_hdr->header_length);
    LOG(LOG_LVL_INFO, "\tota type: %x\r\n", ota_hdr->ota_type);
    LOG(LOG_LVL_INFO, "\tdst: %x\r\n", ota_hdr->ota_dest);
    LOG(LOG_LVL_INFO, "\tota file len: %x\r\n", ota_hdr->ota_file_len);
    LOG(LOG_LVL_INFO, "\tota verify len: %x\r\n", ota_hdr->ota_file_verify_length);
    LOG(LOG_LVL_INFO, "\tfw version: %s\r\n", ota_hdr->raw_data_version);
    LOG(LOG_LVL_INFO, "\tfw file len: %x\r\n", ota_hdr->raw_data_len);
    LOG(LOG_LVL_INFO, "\tfw verify len: %x\r\n", ota_hdr->raw_data_verify_length);
    LOG(LOG_LVL_INFO, "\theader sum: %x\r\n", ota_hdr->header_sum);

    // TODO �������Ӳ������
    if (ota_hdr->ota_type != OTA_TYPE_COMPRESS) {
        LOG(LOG_LVL_INFO, "Type error, only support compress\r\n");
        return LN_FALSE;
    }

    // ����ota��������ݱ�����
    if (ota_hdr->ota_file_len > OTA_SPACE_SIZE) {
        LOG(LOG_LVL_INFO, "ota file too big: %x, limits: %x\r\n",
                ota_hdr->ota_file_len, OTA_SPACE_SIZE);
        return LN_FALSE;
    }

    // TODO Ŀ�������С���
    // ota_hdr->ota_dest

    // ota headerУ��
    uint8_t *buf = (uint8_t *)ota_hdr;
    uint32_t sum = 0;

    // header_length������ͷ���ȣ���ȥ�������������4���ֽ�<����sumֵ��λ��>
    for (int i = 0; i < ota_hdr->header_length - sizeof(uint32_t); i++)
        sum += buf[i];

    uint8_t *tmp_ptr = (uint8_t *)ota_hdr + ota_hdr->header_length - 4;
    uint32_t header_sum = tmp_ptr[3] << 24 | tmp_ptr[2] << 16 | tmp_ptr[1] << 8 | tmp_ptr[0] << 0;
    if (sum != ota_hdr->header_sum) {
        LOG(LOG_LVL_INFO, "Header sum error %x, actually %x\r\n",
                ota_hdr->header_sum, sum);
        for (int i = 0; i < ota_hdr->header_length - sizeof(uint32_t); i++)
            LOG(LOG_LVL_ERROR, "%x ", buf[i]);
        LOG(LOG_LVL_ERROR, "\r\n");
        return LN_FALSE;
    }

    return LN_TRUE;
}

/**
 * @brief get ota ability
 *
 * @param[out] image_size:  max image size
 * @param[out] type:   TUYA_OTA_TYPE_E, full package or compress package use TUYA_OTA_FULL, difference ota use
 * TUYA_OTA_DIFF
 * @note This API is used for get chip ota ability
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_ota_get_ability(uint32_t *image_size, TUYA_OTA_TYPE_E *type)
{
   *image_size = OTA_SPACE_SIZE;
    *type = TUYA_OTA_FULL;
    return OPRT_OK;
}

/**
 * @brief ota start notify
 *
 * @param[in] image_size:  image size
 * @param[in] type:        ota type
 * @param[in] path:        ota path
 *
 * @note This API is used for ota start notify
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_ota_start_notify(uint32_t image_size, TUYA_OTA_TYPE_E type, TUYA_OTA_PATH_E path)
{
#undef  LN_ALIGN_UP
#undef  LN_ALIGN_DOWN
#undef  LN_IS_ALIGNED
#undef  LN_FLASH_ALIGN_SZIE

#define LN_ALIGN_UP(x, align)        (((x) + (align) - 1) & ~((align) - 1))
#define LN_ALIGN_DOWN(x, align)      ((x) & ~((align) - 1))
#define LN_IS_ALIGNED(x, align)      (((x) & (align - 1)) == 0)
#define LN_FLASH_ALIGN_SZIE 4096

    if (LN_ALIGN_UP(image_size, LN_FLASH_ALIGN_SZIE) > OTA_SPACE_SIZE)
    {
        return OPRT_OS_ADAPTER_OTA_START_INFORM_FAILED;
    }

    tkl_flash_erase(OTA_SPACE_OFFSET, LN_ALIGN_UP(image_size, LN_FLASH_ALIGN_SZIE));
    LOG(LOG_LVL_INFO, "[ota start] ==> sector_num=%d, image_size = 0x%x; Aligned: %d, Aligned size: %d\r\n",
            LN_ALIGN_UP(image_size, LN_FLASH_ALIGN_SZIE) / SIZE_4K,
            image_size,
            LN_IS_ALIGNED(image_size, LN_FLASH_ALIGN_SZIE),
            LN_ALIGN_UP(image_size, LN_FLASH_ALIGN_SZIE));

    memset(&_ota_hdr, 0, sizeof(struct ota_header));

    return OPRT_OK;
}

/**
 * @brief ota data process
 *
 * @param[in] pack:       point to ota pack
 * @param[in] remain_len: ota pack remain len
 *
 * @note This API is used for ota data process
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_ota_data_process(TUYA_OTA_DATA_T *pack, uint32_t *remain_len)
{
    int ret = 0;
    static unsigned int total_pos = 0;

    /**
     * 1. handle first packet, read ota header to check ota firmware version and fw size
     */
    static uint8_t ota_hdr_is_checked = 0;
    static uint16_t recved_len = 0;

    uint8_t *ota_hdr_buff = (uint8_t *)(&_ota_hdr);

    LOG(LOG_LVL_TRACE, "[%s:%d] total_len:%d; offset:%d, len:%d, remain_len:%d\r\n",
            __func__, __LINE__, pack->total_len, pack->offset, pack->len, *remain_len);

    if (ota_hdr_is_checked == 0) {
        if ((pack->offset == 0) && (pack->len >= sizeof(struct ota_header))) {
            ret = __ota_download_precheck(APP_SPACE_OFFSET, (struct ota_header *)pack->data);
            if (ret == LN_FALSE) {
                recved_len = 0;
                return OPRT_OS_ADAPTER_OTA_PROCESS_FAILED;
            }
            memcpy(ota_hdr_buff, pack->data, sizeof(struct ota_header));
            ota_hdr_is_checked = 1;
            recved_len = 0;

            LOG(LOG_LVL_INFO, "[%s:%d] first packet get hdr\r\n", __func__, __LINE__);
        } else { /* continue recv data from uplayer until received 'sizeof(struct ota_header)' */
            if ((recved_len + pack->len) <= sizeof(struct ota_header)) {
                memcpy(ota_hdr_buff + recved_len, pack->data, pack->len);
                recved_len += pack->len;
                *remain_len=0;

                LOG(LOG_LVL_INFO, "[%s:%d] continue to get hdr\r\n", __func__, __LINE__);
                return OPRT_OK;
            } else {
                memcpy(ota_hdr_buff + recved_len, pack->data, \
                        sizeof(struct ota_header) - recved_len);
                ret = __ota_download_precheck(APP_SPACE_OFFSET, (struct ota_header *)ota_hdr_buff);
                if (ret == LN_FALSE) {
                    recved_len = 0;
                    return OPRT_OS_ADAPTER_OTA_PROCESS_FAILED;
                }
                ota_hdr_is_checked = 1;

                tkl_flash_write(OTA_SPACE_OFFSET, ota_hdr_buff, recved_len);
                recved_len = 0;
            }
        }
    }

    tkl_flash_write(OTA_SPACE_OFFSET + pack->offset, pack->data, pack->len);
    LOG(LOG_LVL_TRACE, "[%s:%d] ota write data, %x\r\n", __func__, __LINE__, OTA_SPACE_OFFSET + pack->offset);
    *remain_len=0;

    if ((pack->offset + pack->len) == pack->total_len) {
        ota_hdr_is_checked = 0;
        LOG(LOG_LVL_INFO, "[%s:%d] OTA FW write complete\r\n", __func__, __LINE__);
    }

    return OPRT_OK;
}

/**
 * @brief ota end notify
 *
 * @param[in] reset:  ota reset
 *
 * @note This API is used for ota end notify
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_ota_end_notify(BOOL_T reset)
{
    LOG(LOG_LVL_INFO, "[%s:%d] ota end, reset flag:%d \r\n",
            __func__, __LINE__, reset);

    // tuyaos �Ѿ���֤�ļ��������ԣ��˴������ٴ�У��
//    if(0 != __ota_verify_download()){
//        return OPRT_OS_ADAPTER_OTA_VERIFY_FAILED;
//    }

    // reboot  execute by another cmd interface
    if (reset) {
        LOG(LOG_LVL_INFO, "[%s:%d] reboot... \r\n", __func__, __LINE__);
        //OS_MsDelay(1000);
        ln_chip_reboot();
    }

    return OPRT_OK;
}

/**
 * @brief get old firmware info
 *
 * @param[out] image_size:  max image size
 * @param[out] type:        ota type
 *
 * @note This API is used for old firmware info, and only used in resumes transmission at break-points
 * @note Only use for ble sub device
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_ota_get_old_firmware_info(TUYA_OTA_FIRMWARE_INFO_T **info)
{
    // --- BEGIN: user implements ---
    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}
