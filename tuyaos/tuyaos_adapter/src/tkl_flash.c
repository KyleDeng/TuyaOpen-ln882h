/**
 * @file tkl_flash.c
 * @brief this file was auto-generated by tuyaos v&v tools, developer can add implements between BEGIN and END
 * 
 * @warning: changes between user 'BEGIN' and 'END' will be keeped when run tuyaos v&v tools
 *           changes in other place will be overwrited and lost
 *
 * @copyright Copyright 2020-2021 Tuya Inc. All Rights Reserved.
 * 
 */

// --- BEGIN: user defines and implements ---
#include <stdint.h>
#include "tkl_flash.h"
#include "tuya_error_code.h"
#include "tkl_mutex.h"
#include "log.h"
#include "hal/hal_flash.h"
#include "utils/debug/log.h"
// --- END: user defines and implements ---

#define FLH_BLOCK_SZ            (0x1000)
#define FLH_TOTAL_SZ            (0x200000)

#define TUYA_SPACE_OFFSET       (FLH_TOTAL_SZ - TUYA_SPACE_SIZE)
#define TUYA_SPACE_SIZE         (1024 * 212)

/************************************************************
      app    res     kvp      uf      kv      simpl   swap
____+____+__________+__+_____________+__+____________+____+
|   |    |          |  |             |  |            |    |
|   |    |          |  |             |  |            |    |
|   | 16K|     52K  |4K|     64K     |4K|       64K  | 16K|
|   |    |          |  |             |  |            |    |
----+----+----------+--+-------------+--+------------+----+
0                                         2048K  2M
*************************************************************
total used 220k
**************************************************************/

#define UF1_BASE                    (TUYA_SPACE_OFFSET)
#define UF1_SIZE                    (96 * 1024)
#define UF2_BASE                    (UF1_BASE + UF1_SIZE)
#define UF2_SIZE                    (32 * 1024)

#define TY_KV_PROTECT_BASE          (UF2_BASE + UF2_SIZE)
#define TY_KV_PROTECT_SIZE          (4 * 1024)

#define TY_KV_KEY_BASE              (TY_KV_PROTECT_BASE + TY_KV_PROTECT_SIZE)
#define TY_KV_KEY_SIZE              (4 * 1024)

#define SIMPL_BASE                  (TY_KV_KEY_BASE + TY_KV_KEY_SIZE)
#define SIMPL_SIZE                  (64 * 1024)

#define SWAP_BASE                   (SIMPL_BASE + SIMPL_SIZE)
#define SWAP_SIZE                   (12 * 1024)


#if ((SWAP_BASE + SWAP_SIZE) > (TUYA_SPACE_OFFSET + TUYA_SPACE_SIZE))
#error "Flash map error! Please check 'flash_partition_table.h'."
#endif

typedef struct {
    char *uuid;
    char *authkey;
} tuya_iot_license_t;

static TKL_MUTEX_HANDLE tkl_flash_mutex = NULL;

/**
 * @brief read flash
 *
 * @param[in] addr: flash address
 * @param[out] dst: pointer of buffer
 * @param[in] size: size of buffer
 *
 * @note This API is used for reading flash.
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_flash_read(uint32_t addr, uint8_t *dst, uint32_t size)
{
    if (NULL == dst) {
        return OPRT_INVALID_PARM;
    }

    tkl_flash_lock(addr, size);
    hal_flash_read(addr, size, (uint8_t *)dst);
    tkl_flash_unlock(addr, size);

    return OPRT_OK;
}

/**
 * @brief write flash
 *
 * @param[in] addr: flash address
 * @param[in] src: pointer of buffer
 * @param[in] size: size of buffer
 *
 * @note This API is used for writing flash.
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_flash_write(uint32_t addr, const uint8_t *src, uint32_t size)
{
    if (NULL == src) {
        return OPRT_INVALID_PARM;
    }

    tkl_flash_lock(addr, size);
    hal_flash_program(addr, size, (uint8_t *)src);
    tkl_flash_unlock(addr, size);
    return OPRT_OK;
}

/**
 * @brief erase flash
 *
 * @param[in] addr: flash address
 * @param[in] size: size of flash block
 *
 * @note This API is used for erasing flash.
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_flash_erase(uint32_t addr, uint32_t size)
{
    tkl_flash_lock(addr, size);
    hal_flash_erase(addr, size);
    tkl_flash_unlock(addr, size);
    return OPRT_OK;
}

/**
 * @brief lock flash
 *
 * @param[in] addr: lock begin addr
 * @param[in] size: lock area size
 *
 * @note This API is used for lock flash.
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_flash_lock(uint32_t addr, uint32_t size)
{
    if (NULL==tkl_flash_mutex) {
        tkl_mutex_create_init(&tkl_flash_mutex);
    }
    tkl_mutex_lock(tkl_flash_mutex);
    return OPRT_OK;
}

/**
 * @brief unlock flash
 *
 * @param[in] addr: unlock begin addr
 * @param[in] size: unlock area size
 *
 * @note This API is used for unlock flash.
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_flash_unlock(uint32_t addr, uint32_t size)
{
    if (NULL!=tkl_flash_mutex) {
        tkl_mutex_unlock(tkl_flash_mutex);
    }
    return OPRT_OK;
}

/**
 * @brief get flash information
 *
 * @param[out] info: the description of the flash
 *
 * @note This API is used to get description of storage.
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_flash_get_one_type_info(TUYA_FLASH_TYPE_E type, TUYA_FLASH_BASE_INFO_T *info)
{
    if ((type > TUYA_FLASH_TYPE_MAX) || (info == NULL)) {
        return OPRT_INVALID_PARM;
    }
    
    switch (type) {
        case TUYA_FLASH_TYPE_UF:
            info->partition_num = 1;
            info->partition[0].block_size =  FLH_BLOCK_SZ;
            info->partition[0].start_addr = UF1_BASE;
            info->partition[0].size = UF1_SIZE;
//            info->partition[1].start_addr = UF2_BASE;
//            info->partition[1].size = UF2_SIZE;
            break;

        case TUYA_FLASH_TYPE_KV_DATA:
            info->partition_num = 1;
            info->partition[0].block_size = FLH_BLOCK_SZ;
            info->partition[0].start_addr = SIMPL_BASE;
            info->partition[0].size = SIMPL_SIZE;
            break;

        case TUYA_FLASH_TYPE_KV_SWAP:
            info->partition_num = 1;
            info->partition[0].block_size = FLH_BLOCK_SZ;
            info->partition[0].start_addr = SWAP_BASE;
            info->partition[0].size = SWAP_SIZE;
            break;

        case TUYA_FLASH_TYPE_KV_KEY:
            info->partition_num = 1;
            info->partition[0].block_size = FLH_BLOCK_SZ;
            info->partition[0].start_addr = TY_KV_KEY_BASE;
            info->partition[0].size = TY_KV_KEY_SIZE;
            break;

#if defined(KV_PROTECTED_ENABLE) && (KV_PROTECTED_ENABLE==1)
        case TUYA_FLASH_TYPE_KV_PROTECT:
            info->partition_num = 1;
            info->partition[0].block_size = FLH_BLOCK_SZ;
            info->partition[0].start_addr = TY_KV_PROTECT_BASE;
            info->partition[0].size = TY_KV_PROTECT_SIZE;
            break;
#endif // KV_PROTECTED_ENABLE==1

        default:
            return OPRT_INVALID_PARM;
    }

    return OPRT_OK;
}

/**
* @brief tuya_iot_license_read
*
* @param[in] license: iot license struct pointer
*
* @note This API is used for read license .
*
* @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
*/
int tuya_iot_license_read(tuya_iot_license_t *license)
{
    return OPRT_NOT_SUPPORTED;
}