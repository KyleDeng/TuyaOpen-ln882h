/**
 * @file tkl_timer.c
 * @brief this file was auto-generated by tuyaos v&v tools, developer can add implements between BEGIN and END
 * 
 * @warning: changes between user 'BEGIN' and 'END' will be keeped when run tuyaos v&v tools
 *           changes in other place will be overwrited and lost
 *
 * @copyright Copyright 2020-2021 Tuya Inc. All Rights Reserved.
 * 
 */

// --- BEGIN: user defines and implements ---
#include "tkl_timer.h"
#include "tuya_error_code.h"
#include "osal/osal.h"
#include "hal/hal_timer.h"
// --- END: user defines and implements ---

#define LN_TIMER_NUM_MAX 3

#define TIM_LOAD_VALUE_MAX  (0xFFFFFFUL)
#define TIM_PER_CNT_TIME    (1U)         // uint: us, 1us
#define TIM_MAX_DIV         (0xFFU)

typedef struct  {
    TUYA_TIMER_NUM_E timer_id;
    uint32_t ln_tim_base;
    IRQn_Type irq;
}TUYA_LN_TIM_CNV_S;

#define GET_TIM_BASE(timer_id) tuya_ln_tim_map[timer_id].ln_tim_base
#define GET_TIM_IRQ(timer_id) tuya_ln_tim_map[timer_id].irq

TUYA_LN_TIM_CNV_S tuya_ln_tim_map[LN_TIMER_NUM_MAX] = {
    {TUYA_TIMER_NUM_0, TIMER0_BASE, TIMER0_IRQn},
    {TUYA_TIMER_NUM_1, TIMER1_BASE, TIMER1_IRQn},
    {TUYA_TIMER_NUM_2, TIMER2_BASE, TIMER2_IRQn},
    // {TUYA_TIMER_NUM_3, TIMER3_BASE, TIMER3_IRQn},
};

static TUYA_TIMER_BASE_CFG_T __tim_cfg_info[LN_TIMER_NUM_MAX] = {0};

/**
 * @brief timer init
 *
 * @param[in] timer_id timer id
 * @param[in] cfg timer configure
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_timer_init(TUYA_TIMER_NUM_E timer_id, TUYA_TIMER_BASE_CFG_T *cfg)
{
    if (timer_id>=LN_TIMER_NUM_MAX || NULL == cfg->cb) {
        return OPRT_INVALID_PARM;
    }

    __tim_cfg_info[timer_id].mode = cfg->mode;
    __tim_cfg_info[timer_id].cb = cfg->cb;
    __tim_cfg_info[timer_id].args = cfg->args;

    return OPRT_OK;
}

/**
 * @brief timer start
 *
 * @param[in] timer_id timer id
 * @param[in] us when to start
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_timer_start(TUYA_TIMER_NUM_E timer_id, uint32_t us)
{
    uint32_t apb0_clk = 0;
    uint32_t load_value = 0;

    apb0_clk = hal_clock_get_apb0_clk();
    if (us >= 0xFFFFFFFF) {
        load_value = TIM_LOAD_VALUE_MAX;
    } else {
        load_value = (us + TIM_PER_CNT_TIME - 1) / TIM_PER_CNT_TIME;
    }

    if (timer_id >= LN_TIMER_NUM_MAX) {
        return OPRT_INVALID_PARM;
    }

    if (load_value > TIM_LOAD_VALUE_MAX) {
        tkl_log_output("timer %d start, us too long\r\n", timer_id);
        return OPRT_INVALID_PARM;
    }

    tim_init_t_def tim_cfg;
    memset(&tim_cfg, 0, sizeof(tim_cfg));
    tim_cfg.tim_mode = TIM_USER_DEF_CNT_MODE;
    tim_cfg.tim_load_value = load_value;
    tim_cfg.tim_div = TIM_PER_CNT_TIME * (apb0_clk/1000000) - 1;

    hal_tim_init(GET_TIM_BASE(timer_id), &tim_cfg);
    hal_tim_en(GET_TIM_BASE(timer_id), HAL_ENABLE);
    hal_tim_it_cfg(GET_TIM_BASE(timer_id), TIM_IT_FLAG_ACTIVE, HAL_ENABLE);
    NVIC_EnableIRQ(GET_TIM_IRQ(timer_id));

    return OPRT_OK;
}

/**
 * @brief timer stop
 *
 * @param[in] timer_id timer id
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_timer_stop(TUYA_TIMER_NUM_E timer_id)
{
    if (timer_id>=LN_TIMER_NUM_MAX) {
        return OPRT_INVALID_PARM;
    }

    NVIC_DisableIRQ(GET_TIM_IRQ(timer_id));
    hal_tim_it_cfg(GET_TIM_BASE(timer_id), TIM_IT_FLAG_ACTIVE, HAL_DISABLE);
    hal_tim_clr_it_flag(GET_TIM_BASE(timer_id), TIM_IT_FLAG_ACTIVE);
    hal_tim_en(GET_TIM_BASE(timer_id), HAL_DISABLE);

    return OPRT_OK;
}

/**
 * @brief timer deinit
 *
 * @param[in] timer_id timer id
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_timer_deinit(TUYA_TIMER_NUM_E timer_id)
{
    if (timer_id>=LN_TIMER_NUM_MAX) {
        return OPRT_INVALID_PARM;
    }

    NVIC_DisableIRQ(GET_TIM_IRQ(timer_id));
    hal_tim_it_cfg(GET_TIM_BASE(timer_id), TIM_IT_FLAG_ACTIVE, HAL_DISABLE);
    hal_tim_clr_it_flag(GET_TIM_BASE(timer_id), TIM_IT_FLAG_ACTIVE);
    hal_tim_en(GET_TIM_BASE(timer_id), HAL_DISABLE);

    return OPRT_OK;
}

/**
 * @brief current timer get
 *
 * @param[in] timer_id timer id
 * @param[out] us timer
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_timer_get_current_value(TUYA_TIMER_NUM_E timer_id, uint32_t *us)
{
    if (timer_id>=LN_TIMER_NUM_MAX || NULL==us) {
        return OPRT_INVALID_PARM;
    }

    *us = hal_tim_get_current_cnt_value(GET_TIM_BASE(timer_id));

    return OPRT_OK;
}

/**
 * @brief timer get
 *
 * @param[in] timer_id timer id
 * @param[out] us timer interval
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_timer_get(TUYA_TIMER_NUM_E timer_id, uint32_t *us)
{
    if (timer_id>=LN_TIMER_NUM_MAX || NULL==us) {
        return OPRT_INVALID_PARM;
    }

    *us = hal_tim_get_current_cnt_value(GET_TIM_BASE(timer_id));

    return OPRT_OK;
}

void TIMER0_IRQHandler(void)
{
    TUYA_TIMER_BASE_CFG_T *tuya_tim_handler = &__tim_cfg_info[TUYA_TIMER_NUM_0];

    if (hal_tim_get_it_flag(TIMER0_BASE, TIM_IT_FLAG_ACTIVE)) {
        hal_tim_clr_it_flag(TIMER0_BASE, TIM_IT_FLAG_ACTIVE);

        if (tuya_tim_handler->mode == TUYA_TIMER_MODE_ONCE) {
            tkl_timer_stop(TUYA_TIMER_NUM_0);
        }

        if (NULL != tuya_tim_handler->cb) {
            tuya_tim_handler->cb(tuya_tim_handler->args);
        }
    }
}

void TIMER1_IRQHandler(void)
{
    TUYA_TIMER_BASE_CFG_T *tuya_tim_handler = &__tim_cfg_info[TUYA_TIMER_NUM_1];

    if (hal_tim_get_it_flag(TIMER1_BASE, TIM_IT_FLAG_ACTIVE)) {
        hal_tim_clr_it_flag(TIMER1_BASE, TIM_IT_FLAG_ACTIVE);

        if (tuya_tim_handler->mode == TUYA_TIMER_MODE_ONCE) {
            tkl_timer_stop(TUYA_TIMER_NUM_1);
        }

        if (NULL != tuya_tim_handler->cb) {
            tuya_tim_handler->cb(tuya_tim_handler->args);
        }
    }
}

void TIMER2_IRQHandler(void)
{
    TUYA_TIMER_BASE_CFG_T *tuya_tim_handler = &__tim_cfg_info[TUYA_TIMER_NUM_2];

    if (hal_tim_get_it_flag(TIMER2_BASE, TIM_IT_FLAG_ACTIVE)) {
        hal_tim_clr_it_flag(TIMER2_BASE, TIM_IT_FLAG_ACTIVE);

        if (tuya_tim_handler->mode == TUYA_TIMER_MODE_ONCE) {
            tkl_timer_stop(TUYA_TIMER_NUM_2);
        }

        if (NULL != tuya_tim_handler->cb) {
            tuya_tim_handler->cb(tuya_tim_handler->args);
        }
    }
}

